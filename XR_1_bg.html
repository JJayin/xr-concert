<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>XR Concert_Unreal Engine Project</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=Inter:wght@300;500;800&family=JetBrains+Mono:wght@400;700&family=Noto+Sans+KR:wght@300;500;700;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-color:#050505;
      --surface: rgba(255,255,255,0.04);
      --muted: #9da6b2;
      --text-main:#ffffff;
      --accent-acid:#CCFF00;
      --accent-red:#ff3b3b;
      --glass-bg: rgba(255,255,255,0.03);
      --font-head: 'Archivo Black', sans-serif;
      --font-ui: 'Inter', system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans KR';
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:transparent;color:var(--text-main);font-family:var(--font-ui);-webkit-font-smoothing:antialiased}

    /* Page container + layout */
    .container{width:100%;max-width:1200px;margin:0 auto;padding:0 20px}
    .section-padding{padding:100px 0}

    /* Background video */
    body{
      position:relative; overflow-x:hidden;
      background:#050505; /* Fallback color if video fails to load */
    }
    .bg-video{
      position:fixed; top:0; left:0; width:100vw; height:100vh;
      min-width:100%; min-height:100%;
      object-fit:cover; z-index:-3; pointer-events:none;
      background:#050505; /* Fallback color */
    }
    /* Ensure video is behind everything */
    .orb-container{position:fixed;inset:0;z-index:-1;pointer-events:none}

    /* Top navigation removed per user request */

    /* Hero */
    .hero{min-height:80vh;display:grid;align-items:center;place-items:center;padding:120px 20px}
    .hero-inner{display:grid;grid-template-columns:1fr 420px;gap:48px;align-items:center;width:100%;max-width:1200px}
    .hero-title{font-family:var(--font-head);font-size:clamp(3rem,9vw,6rem);line-height:0.92;text-transform:uppercase;color:var(--text-main);margin:0 0 8px 0;text-align:center;position:relative}
    .hero-title-inner{position:relative;display:inline-block;padding:0 6px}
    .hero-title-inner::before,
    .hero-title-inner::after{
      content:attr(data-text);
      position:absolute;left:0;top:0;width:100%;height:100%;overflow:visible;pointer-events:none;
      -webkit-backface-visibility:hidden;backface-visibility:hidden;
    }
    .hero-title-inner::before{color:var(--accent-acid);z-index:1;mix-blend-mode:screen;transform:translate3d(-4px,0,0);opacity:0.9;}
    .hero-title-inner::after{color:var(--accent-red);z-index:1;mix-blend-mode:screen;transform:translate3d(4px,0,0);opacity:0.9}
    .hero-title-inner{z-index:2}
    /* subtle randomized glitch timing */
    @keyframes glitchA{0%{transform:none}10%{transform:translate3d(-2px,-1px,0)}20%{transform:translate3d(2px,1px,0)}30%{transform:none}40%{transform:translate3d(-1px,2px,0)}50%{transform:none}100%{transform:none}}
    @keyframes glitchB{0%{transform:none}8%{transform:translate3d(2px,1px,0)}18%{transform:translate3d(-2px,-1px,0)}28%{transform:none}45%{transform:translate3d(1px,-2px,0)}100%{transform:none}}
    .hero-title-inner::before{animation:glitchA 2.8s infinite linear}
    .hero-title-inner::after{animation:glitchB 3.2s infinite linear}

    .hero-subtitle{display:block;font-family:'Press Start 2P', monospace;font-size:clamp(0.6rem,1.6vw,0.95rem);font-weight:400;color:var(--text-main);text-transform:none;margin:8px auto 0 auto;background:rgba(0,0,0,0.9);padding:10px 14px;border-radius:6px;line-height:1;text-align:center;max-width:min(88%,520px)}
    .hero-copy{color:var(--muted);font-size:1.05rem}

    /* Decorative orbs */
    .orb-container{position:fixed;inset:0;z-index:-1;pointer-events:none}
    .orb{position:absolute;border-radius:50%;filter:blur(80px);opacity:0.55}
    .orb-1{top:10%;left:8%;width:360px;height:360px;background:radial-gradient(circle,var(--accent-acid),transparent 70%)}
    .orb-2{bottom:8%;right:6%;width:520px;height:520px;background:radial-gradient(circle,#4b0082,transparent 70%)}
    .orb-3{top:62%;left:52%;width:220px;height:220px;background:radial-gradient(circle,#001f3f,transparent 70%)}

    /* subtle reveal animations */
    .reveal{opacity:0;transform:translateY(24px) scale(.995);transition:opacity .7s cubic-bezier(.2,.9,.2,1),transform .7s cubic-bezier(.2,.9,.2,1)}
    .reveal.visible{opacity:1;transform:none}

    /* Manifesto highlighted sentence (scroll-to-focus -> presentation) */
    .manifesto-line{display:block;margin:14px auto;max-width:880px;font-weight:700;transition:transform .6s cubic-bezier(.2,.9,.2,1),font-size .6s,color .4s,opacity .6s;opacity:0.95;font-size:1.05rem;cursor:pointer}
    .manifesto-line.focus{font-size:clamp(1.8rem,6vw,3.8rem);color:var(--accent-acid);transform:translateY(-8px);text-shadow:0 8px 30px rgba(0,0,0,0.6);opacity:1}

    /* Presentation overlay when manifesto is clicked */
    .present-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(2,2,2,0.92);z-index:3000;opacity:0;pointer-events:none;transition:opacity .28s ease}
    .present-overlay.open{opacity:1;pointer-events:auto}
    .present-spotlight{position:absolute;inset:0;background:radial-gradient(circle at 50% 40%, rgba(255,255,255,0.05) 0%, rgba(255,255,255,0.02) 15%, transparent 40%);pointer-events:none;mix-blend-mode:overlay}
    .manifesto-present-wrap{position:relative;max-width:1100px;padding:36px 48px;border-radius:12px;display:flex;align-items:center;justify-content:center}
    .manifesto-present-text{color:var(--accent-acid);font-weight:800;font-family:var(--font-head);font-size:clamp(2rem,7vw,5rem);line-height:1;text-align:center;padding:8px;transform:translateY(8px) scale(.98);opacity:0;transition:transform .36s cubic-bezier(.2,.9,.2,1),opacity .36s}
    /* Purpose content style */
    .purpose-content-wrap{position:relative;max-width:900px;padding:60px 48px;border-radius:24px;max-height:85vh;overflow-y:auto;opacity:0;transition:opacity .4s,background .3s ease,backdrop-filter .3s ease,border-color .3s ease,box-shadow .3s ease;display:none;
      /* Glassmorphism effect - more transparent */
      background:rgba(255,255,255,0.02);
      backdrop-filter:blur(20px) saturate(180%);
      -webkit-backdrop-filter:blur(20px) saturate(180%);
      border:1px solid rgba(255,255,255,0.08);
      box-shadow:0 8px 32px rgba(0,0,0,0.1),inset 0 1px 0 rgba(255,255,255,0.1);
    }
    .present-overlay.open .purpose-content-wrap{opacity:1;display:block}
    .purpose-content-wrap:hover{background:rgba(255,255,255,0.04);
      backdrop-filter:blur(25px) saturate(200%) brightness(1.1);
      -webkit-backdrop-filter:blur(25px) saturate(200%) brightness(1.1);
      border-color:rgba(255,255,255,0.15);
      box-shadow:0 12px 40px rgba(0,0,0,0.15),inset 0 2px 8px rgba(255,255,255,0.2),inset 0 -1px 0 rgba(255,255,255,0.1);
    }
    .purpose-title{font-family:var(--font-head);font-size:clamp(3rem,7vw,5rem);color:var(--accent-acid);margin-bottom:40px;text-align:center;text-transform:uppercase;letter-spacing:2px;text-shadow:0 0 30px rgba(204,255,0,0.4);opacity:0;transform:translateY(30px) scale(0.95);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1)}
    .purpose-content-wrap.scrolled .purpose-title{opacity:1;transform:none}
    .purpose-content{font-family:var(--font-ui);font-size:clamp(1.2rem,2.2vw,1.6rem);line-height:2;color:var(--text-main);text-align:left}
    .purpose-content p{margin-bottom:28px;opacity:0.95;opacity:0;transform:translateX(-20px);transition:opacity .6s ease,transform .6s cubic-bezier(.2,.9,.2,1)}
    .purpose-content p.visible{opacity:0.95;transform:translateX(0)}
    .purpose-content p:first-of-type{font-size:clamp(1.4rem,2.5vw,1.8rem);font-weight:500;margin-bottom:40px}
    .purpose-quote-label{font-size:clamp(0.9rem,1.5vw,1.1rem);color:rgba(255,255,255,0.5);text-transform:uppercase;letter-spacing:2px;margin-bottom:16px;text-align:center;font-weight:600;opacity:0;transform:translateY(10px);transition:opacity .6s ease,transform .6s cubic-bezier(.2,.9,.2,1)}
    .purpose-quote-label.visible{opacity:1;transform:translateY(0)}
    .purpose-quote{background:rgba(204,255,0,0.03);border-left:2px solid rgba(204,255,0,0.3);padding:28px 36px;margin:36px 0;border-radius:16px;font-size:clamp(1.4rem,2.5vw,1.8rem);font-weight:600;color:var(--accent-acid);font-style:italic;text-align:center;position:relative;opacity:0;transform:translateY(20px);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1),background .3s ease,backdrop-filter .3s ease,border-color .3s ease,box-shadow .3s ease;
      /* Glassmorphism for quote */
      backdrop-filter:blur(10px) saturate(150%);
      -webkit-backdrop-filter:blur(10px) saturate(150%);
      border:1px solid rgba(204,255,0,0.15);
      box-shadow:0 4px 16px rgba(0,0,0,0.05),inset 0 1px 0 rgba(204,255,0,0.1);
    }
    .purpose-quote.visible{opacity:1;transform:translateY(0)}
    .purpose-quote::before{content:'"';position:absolute;left:20px;top:12px;font-size:2.5rem;opacity:0.15;font-family:serif}
    .purpose-quote::after{content:'';position:absolute;inset:0;border-radius:16px;background:linear-gradient(135deg,rgba(204,255,0,0.15) 0%,rgba(204,255,0,0.05) 50%,transparent 100%);opacity:0;transition:opacity .3s ease;pointer-events:none;z-index:-1}
    .purpose-quote:hover{background:rgba(204,255,0,0.06);
      backdrop-filter:blur(15px) saturate(180%) brightness(1.15);
      -webkit-backdrop-filter:blur(15px) saturate(180%) brightness(1.15);
      border-color:rgba(204,255,0,0.4);
      box-shadow:0 6px 24px rgba(204,255,0,0.2),inset 0 2px 6px rgba(204,255,0,0.25),inset 0 -1px 0 rgba(204,255,0,0.1);
    }
    .purpose-quote:hover::after{opacity:1}
    .purpose-content strong{color:var(--accent-acid);font-weight:700;opacity:0;transform:scale(0.8);transition:opacity .5s ease,transform .5s cubic-bezier(.2,.9,.2,1)}
    .purpose-content p.visible strong{opacity:1;transform:scale(1);animation:highlight 0.6s ease}
    .purpose-content a{color:var(--accent-acid);text-decoration:none;font-weight:700;border-bottom:2px solid var(--accent-acid);transition:all .3s ease;opacity:0;transform:translateY(4px)}
    .purpose-content p.visible a{opacity:1;transform:translateY(0)}
    .purpose-content a:hover{color:#fff;border-bottom-color:#fff;text-shadow:0 0 15px rgba(204,255,0,0.6)}
    .purpose-content img{width:100%;max-width:100%;height:auto;border-radius:16px;margin:32px 0;opacity:0;transform:translateY(20px) scale(0.98);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1);box-shadow:0 8px 32px rgba(0,0,0,0.3);object-fit:cover}
    .purpose-content img.visible{opacity:1;transform:translateY(0) scale(1)}
    .purpose-image-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin:24px 0;opacity:0;transform:translateY(20px);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1)}
    .purpose-image-grid.visible{opacity:1;transform:translateY(0)}
    .purpose-image-grid img{width:100%;height:auto;border-radius:16px;margin:0;box-shadow:0 8px 32px rgba(0,0,0,0.3);object-fit:cover;display:block}
    .purpose-image-grid img:nth-child(5){grid-column:1/-1;max-width:50%;margin:16px auto 0;border-radius:16px}
    .purpose-image-grid.asset-grid img{aspect-ratio:1/1;height:auto;object-fit:cover}
    .purpose-image-grid.asset-grid img:nth-child(5){grid-column:auto;max-width:100%;margin:0}
    @media (max-width:768px){.purpose-image-grid{grid-template-columns:1fr}.purpose-image-grid img:nth-child(5){max-width:100%}}
    .artist-profile{background:rgba(255,255,255,0.02);backdrop-filter:blur(15px) saturate(150%);-webkit-backdrop-filter:blur(15px) saturate(150%);border:1px solid rgba(255,255,255,0.08);border-radius:20px;padding:32px;margin:24px 0;opacity:0;transform:translateY(20px);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1)}
    .artist-profile.visible{opacity:1;transform:translateY(0)}
    .artist-profile-item{margin-bottom:20px;padding-bottom:20px;border-bottom:1px solid rgba(255,255,255,0.06);opacity:0;transform:translateX(-20px);transition:opacity .6s ease,transform .6s cubic-bezier(.2,.9,.2,1);position:relative;z-index:2}
    .artist-profile-item:last-child{margin-bottom:0;padding-bottom:0;border-bottom:none}
    .artist-profile.visible .artist-profile-item{opacity:1;transform:translateX(0)}
    .artist-profile.visible .artist-profile-item:nth-of-type(1){transition-delay:0.1s}
    .artist-profile.visible .artist-profile-item:nth-of-type(2){transition-delay:0.2s}
    .artist-profile.visible .artist-profile-item:nth-of-type(3){transition-delay:0.3s}
    .artist-profile-label{opacity:1 !important}
    .artist-profile-value{opacity:1 !important}
    .artist-profile-label{font-size:clamp(0.9rem,1.5vw,1rem);color:rgba(255,255,255,0.5);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px;font-weight:600}
    .artist-profile-value{font-size:clamp(1.2rem,2vw,1.5rem);color:#fff;font-weight:500;line-height:1.6}
    .artist-profile-value strong{color:var(--accent-acid);font-weight:700}
    .artist-profile-image-wrapper{text-align:center;margin-bottom:32px}
    .artist-profile-image{width:200px;height:200px;border-radius:50%;object-fit:cover;margin:0 auto 16px;display:block;border:3px solid rgba(204,255,0,0.3);box-shadow:0 8px 32px rgba(0,0,0,0.4),0 0 0 8px rgba(255,255,255,0.02);opacity:0;transform:scale(0.8);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1)}
    .artist-profile.visible .artist-profile-image{opacity:1;transform:scale(1)}
    .artist-profile-name{font-size:clamp(1.8rem,3vw,2.4rem);color:var(--accent-acid);font-weight:700;text-align:center;margin-top:16px;opacity:0;transform:translateY(10px);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1);text-shadow:0 0 20px rgba(204,255,0,0.4)}
    .artist-profile.visible .artist-profile-name{opacity:1;transform:translateY(0);transition-delay:0.2s}
    .artist-profile-link{display:inline-flex;align-items:center;gap:8px;color:var(--accent-acid);text-decoration:none;font-weight:700;border-bottom:2px solid var(--accent-acid);transition:all .3s ease;margin-top:16px;opacity:0;transform:translateY(4px)}
    .artist-profile.visible .artist-profile-link{opacity:1;transform:translateY(0);transition-delay:0.5s}
    .artist-profile-link:hover{color:#fff;border-bottom-color:#fff;text-shadow:0 0 15px rgba(204,255,0,0.6)}
    @keyframes highlight{0%{text-shadow:0 0 0 rgba(204,255,0,0)}50%{text-shadow:0 0 20px rgba(204,255,0,0.8)}100%{text-shadow:0 0 0 rgba(204,255,0,0)}}
    .purpose-section{margin-top:40px;padding-top:32px;border-top:1px solid rgba(255,255,255,0.06);opacity:0;transform:translateY(40px);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1)}
    .purpose-section.visible{opacity:1;transform:translateY(0)}
    .purpose-section-title{font-size:clamp(1.6rem,3vw,2rem);color:var(--accent-acid);margin-bottom:24px;font-weight:700;opacity:0;transform:translateX(-30px);transition:opacity .7s ease,transform .7s cubic-bezier(.2,.9,.2,1)}
    .purpose-section.visible .purpose-section-title{opacity:1;transform:translateX(0);animation:slide-in-accent 0.8s ease}
    @keyframes slide-in-accent{0%{transform:translateX(-30px);opacity:0}60%{transform:translateX(10px)}100%{transform:translateX(0);opacity:1}}
    .purpose-content::-webkit-scrollbar{width:8px}
    .purpose-content::-webkit-scrollbar-track{background:rgba(255,255,255,0.02);border-radius:4px}
    .purpose-content::-webkit-scrollbar-thumb{background:rgba(204,255,0,0.3);border-radius:4px}
    .purpose-content::-webkit-scrollbar-thumb:hover{background:rgba(204,255,0,0.5)}
    /* Levels content - card grid style */
    .levels-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:32px;margin-top:40px;opacity:0;transform:translateY(30px);transition:opacity .8s ease,transform .8s cubic-bezier(.2,.9,.2,1)}
    .levels-grid.visible{opacity:1;transform:translateY(0)}
    .level-content-card{background:rgba(255,255,255,0.02);backdrop-filter:blur(15px) saturate(150%);-webkit-backdrop-filter:blur(15px) saturate(150%);border:1px solid rgba(255,255,255,0.08);border-radius:20px;overflow:hidden;transform-style:preserve-3d;transition:all .4s ease;opacity:0;transform:translateY(20px) scale(0.98);position:relative;cursor:pointer;perspective:1000px}
    .level-content-card.visible{opacity:1;transform:translateY(0) scale(1)}
    .level-content-card{--spotlight-x: 50%; --spotlight-y: 50%;}
    .level-content-card::before{content:'';position:absolute;left:var(--spotlight-x);top:var(--spotlight-y);transform:translate(-50%,-50%);width:0;height:0;border-radius:50%;background:radial-gradient(circle, rgba(255,255,220,0.85) 0%, rgba(255,255,220,0.35) 25%, rgba(255,255,220,0.1) 40%, transparent 70%);filter:blur(45px);opacity:0;transition:width .5s cubic-bezier(.2,.9,.2,1),height .5s cubic-bezier(.2,.9,.2,1),opacity .4s ease,left .15s ease,top .15s ease;pointer-events:none;z-index:1}
    .level-content-card:hover::before{width:450px;height:450px;opacity:1}
    .level-content-card:hover{background:rgba(255,255,255,0.04);border-color:rgba(204,255,0,0.3);box-shadow:0 8px 32px rgba(0,0,0,0.2),inset 0 1px 0 rgba(255,255,255,0.1)}
    .level-content-card:hover .level-content-title{color:var(--accent-acid);text-shadow:0 0 25px rgba(204,255,0,0.7),0 0 50px rgba(204,255,0,0.4),0 0 75px rgba(204,255,0,0.2)}
    /* Level media modal */
    .level-media-modal{position:fixed;inset:0;background:rgba(2,2,2,0.95);z-index:4000;opacity:0;pointer-events:none;transition:opacity .3s ease;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px)}
    .level-media-modal.open{opacity:1;pointer-events:auto}
    .level-media-content{position:relative;max-width:90vw;max-height:90vh;border-radius:20px;overflow:hidden;transform:scale(0.9);transition:transform .3s ease;background:rgba(0,0,0,0.8);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px)}
    .level-media-modal.open .level-media-content{transform:scale(1)}
    .level-media-close{position:absolute;right:20px;top:20px;background:rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.2);color:#fff;padding:12px 16px;border-radius:10px;cursor:pointer;z-index:10;font-size:1.2rem;transition:all .3s ease}
    .level-media-close:hover{background:rgba(204,255,0,0.2);border-color:var(--accent-acid);color:var(--accent-acid)}
    .level-media-img,.level-media-video{width:100%;height:auto;max-height:90vh;object-fit:contain;display:block}
    .level-media-video{background:#000}
    .level-content-img-box{width:100%;height:clamp(200px,25vh,280px);background:linear-gradient(135deg,rgba(204,255,0,0.1),rgba(0,0,0,0.3));overflow:hidden;position:relative}
    .level-content-img{width:100%;height:100%;object-fit:cover;display:block;transition:transform .6s ease;opacity:0.8}
    .level-content-card:hover .level-content-img{transform:scale(1.1);opacity:1}
    .level-content-info{padding:28px}
    .level-content-title{font-family:var(--font-head);font-size:clamp(1.8rem,3.5vw,2.5rem);color:var(--accent-acid);margin-bottom:16px;text-transform:uppercase;letter-spacing:1px}
    .level-content-desc{font-family:var(--font-ui);font-size:clamp(1rem,1.8vw,1.2rem);line-height:1.8;color:var(--text-main);opacity:0.9}
    @media (max-width:980px){
      .levels-grid{grid-template-columns:1fr;gap:24px}
    }
    /* Next TOC button - same style as TOC items */
    .purpose-nav-buttons{display:flex;justify-content:space-between;gap:16px;margin-top:60px;width:100%}
    .purpose-nav-buttons.visible .purpose-nav-btn{opacity:1;transform:none}
    .purpose-nav-btn{font-family:var(--font-head);color:var(--text-main);font-size:clamp(1.2rem,2.5vw,2rem);position:relative;cursor:pointer;padding:16px 32px;border-radius:16px;z-index:1;transform-style:preserve-3d;text-align:center;opacity:0;transform:translateY(20px) scale(.992);transition:opacity .5s ease,transform .6s cubic-bezier(.2,.9,.2,1),color .3s ease,text-shadow .3s ease,filter .4s ease,background .3s ease,backdrop-filter .3s ease,border-color .3s ease,box-shadow .3s ease;
      /* Glassmorphism effect */
      background:rgba(255,255,255,0.03);
      backdrop-filter:blur(15px) saturate(150%);
      -webkit-backdrop-filter:blur(15px) saturate(150%);
      border:1px solid rgba(255,255,255,0.1);
      box-shadow:0 4px 20px rgba(0,0,0,0.08),inset 0 1px 0 rgba(255,255,255,0.1);
    }
    .purpose-nav-btn{--spotlight-x: 50%; --spotlight-y: 50%;}
    .purpose-nav-btn::before{content:'';position:absolute;left:var(--spotlight-x);top:var(--spotlight-y);transform:translate(-50%,-50%);width:0;height:0;border-radius:50%;background:radial-gradient(circle, rgba(255,255,220,0.85) 0%, rgba(255,255,220,0.35) 25%, rgba(255,255,220,0.1) 40%, transparent 70%);filter:blur(45px);opacity:0;transition:width .5s cubic-bezier(.2,.9,.2,1),height .5s cubic-bezier(.2,.9,.2,1),opacity .4s ease,left .15s ease,top .15s ease;pointer-events:none;z-index:-1}
    .purpose-nav-btn:hover::before{width:450px;height:450px;opacity:1}
    .purpose-nav-btn::after{content:'';position:absolute;inset:0;border-radius:16px;background:linear-gradient(135deg,rgba(255,255,255,0.1) 0%,rgba(255,255,255,0.05) 50%,transparent 100%);opacity:0;transition:opacity .3s ease;pointer-events:none;z-index:0}
    .purpose-nav-btn:hover::after{opacity:1}
    .purpose-nav-btn:hover{color:var(--accent-acid);text-shadow:0 0 25px rgba(204,255,0,0.7),0 0 50px rgba(204,255,0,0.4),0 0 75px rgba(204,255,0,0.2);
      background:rgba(255,255,255,0.08);
      backdrop-filter:blur(20px) saturate(200%) brightness(1.2);
      -webkit-backdrop-filter:blur(20px) saturate(200%) brightness(1.2);
      border-color:rgba(255,255,255,0.25);
      box-shadow:0 6px 30px rgba(204,255,0,0.15),inset 0 2px 8px rgba(255,255,255,0.3),inset 0 -1px 0 rgba(255,255,255,0.1);
    }
    .purpose-nav-btn:disabled{opacity:0.3;cursor:not-allowed;pointer-events:none}
    .purpose-nav-prev{margin-right:auto}
    .purpose-nav-next{margin-left:auto}
    @media (max-width:768px){.purpose-nav-buttons{flex-direction:column;gap:12px}.purpose-nav-btn{width:100%}.purpose-nav-prev,.purpose-nav-next{margin:0}}
    /* zoom animation classes */
    .manifesto-present-wrap.zooming{transform:scale(1.06);transition:transform .36s cubic-bezier(.2,.9,.2,1)}
    .manifesto-present-text.zooming{transform:scale(1.08) translateY(-6px);opacity:0.14;transition:transform .36s cubic-bezier(.2,.9,.2,1),opacity .28s}
    .present-overlay.open .manifesto-present-text{transform:none;opacity:1}
    .present-close{position:absolute;right:20px;top:18px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer}
    .present-nav{position:absolute;left:12px;right:12px;top:50%;transform:translateY(-50%);display:flex;justify-content:space-between;pointer-events:none}
    .present-btn{background:rgba(0,0,0,0.35);border:1px solid rgba(255,255,255,0.06);color:#fff;padding:12px 14px;border-radius:10px;cursor:pointer;pointer-events:auto}
    .present-counter{position:absolute;bottom:62px;color:rgba(255,255,255,0.6);font-size:0.95rem;width:100%;text-align:center}
    .present-thumbs{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);display:flex;gap:8px;align-items:center}
    .present-thumb{background:rgba(255,255,255,0.06);color:#fff;padding:6px 10px;border-radius:8px;font-size:0.85rem;cursor:pointer;border:1px solid rgba(255,255,255,0.03)}
    .present-thumb.active{background:var(--accent-acid);color:#000;border-color:rgba(0,0,0,0.15);font-weight:700}
    .present-progress{position:absolute;left:12px;right:12px;bottom:8px;height:6px;background:rgba(255,255,255,0.04);border-radius:99px;overflow:hidden}
    .present-progress-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent-acid),#fff);transition:width .28s ease}
    /* hide custom cursor while presenting */
    body.presenting .cursor-dot, body.presenting .cursor-outline{opacity:0;pointer-events:none;transform:scale(.6) !important}

    /* TOC / Stage overlay (zoom-through-title -> spotlights) */
    .toc-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(3,3,3,0.97);z-index:2900;opacity:0;pointer-events:none;transition:opacity .36s ease}
    .toc-overlay.open{opacity:1;pointer-events:auto}
    .stage{position:relative;width:100%;max-width:1100px;padding:40px 20px;display:flex;flex-direction:column;align-items:center;justify-content:flex-start}
    .stage-spotlights{display:none}
    .stage-spot{display:none}

    .toc-list{list-style:none;margin-top:160px;display:flex;flex-direction:column;gap:18px;align-items:center;padding:0;position:relative;perspective:1000px}
    .toc-list li{font-family:var(--font-head);color:var(--text-main);font-size:clamp(2rem,5vw,4.5rem);opacity:0;transform:translateY(20px) scale(.992);transition:opacity .5s ease,transform .6s cubic-bezier(.2,.9,.2,1),color .3s ease,text-shadow .3s ease,filter .4s ease;position:relative;cursor:pointer;padding:12px 24px;border-radius:8px;z-index:1;transform-style:preserve-3d;text-align:center;width:100%}
    .toc-list li.show{opacity:1;transform:none}
    /* Dim other items when one is hovered */
    .toc-list:has(li:hover) li:not(:hover){opacity:0.15;filter:blur(3px);transform:scale(0.95)}
    .toc-list li.dimmed{opacity:0.12 !important;filter:blur(4px) !important;transform:scale(0.94) !important;transition:opacity .4s ease,filter .4s ease,transform .4s ease}
    /* Spotlight effect on hover - follows mouse cursor */
    .toc-list li{--spotlight-x: 50%; --spotlight-y: 50%;}
    .toc-list li::before{content:'';position:absolute;left:var(--spotlight-x);top:var(--spotlight-y);transform:translate(-50%,-50%);width:0;height:0;border-radius:50%;background:radial-gradient(circle, rgba(255,255,220,0.85) 0%, rgba(255,255,220,0.35) 25%, rgba(255,255,220,0.1) 40%, transparent 70%);filter:blur(45px);opacity:0;transition:width .5s cubic-bezier(.2,.9,.2,1),height .5s cubic-bezier(.2,.9,.2,1),opacity .4s ease,left .15s ease,top .15s ease;pointer-events:none;z-index:-1}
    .toc-list li:hover::before{width:450px;height:450px;opacity:1}
    .toc-list li:hover{color:var(--accent-acid);text-shadow:0 0 25px rgba(204,255,0,0.7),0 0 50px rgba(204,255,0,0.4),0 0 75px rgba(204,255,0,0.2)}
    .toc-close{position:absolute;right:20px;top:18px;background:transparent;border:1px solid rgba(255,255,255,0.06);color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer}
    .toc-print-btn{background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);color:var(--accent-acid);padding:8px 16px;border-radius:8px;cursor:pointer;font-size:clamp(0.75rem,1.2vw,0.9rem);font-weight:500;margin-top:32px;opacity:0;transform:translateY(10px);transition:all .4s ease;font-family:var(--font-ui);text-transform:uppercase;letter-spacing:0.5px}
    .toc-print-btn:hover{background:rgba(204,255,0,0.1);border-color:var(--accent-acid);color:#fff;text-shadow:0 0 10px rgba(204,255,0,0.5);transform:translateY(0)}
    .toc-overlay.open .toc-print-btn{opacity:1;transform:translateY(0);transition-delay:0.8s}

    @media (max-width:700px){
      .stage-spot{width:260px;height:260px}
      .toc-list{margin-top:120px}
      .toc-list li{font-size:clamp(1.4rem,4.5vw,2.8rem)}
    }

    /* Big X */
    .big-x-mark{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%) scale(1.2);font-family:var(--font-head);font-size:clamp(10rem,22vw,26rem);color:var(--accent-red);opacity:0;pointer-events:none;transition:opacity .8s,transform .8s}
    .big-x-mark.visible{opacity:0.09;transform:translate(-50%,-50%) rotate(-10deg) scale(1)}

    /* cards and grids */
    .grid-layout{display:grid;grid-template-columns:repeat(2,1fr);gap:28px}
    .grid-item{background:var(--glass-bg);border:1px solid rgba(255,255,255,0.04);padding:42px;border-radius:18px}
    .mono-tag{font-family:monospace;color:var(--accent-acid);display:inline-block;margin-bottom:18px;font-size:.9rem}

    .concept-box{background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);padding:60px;border-radius:18px}

    /* Level grid */
    .level-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:24px;margin-top:24px}
    .level-card{background:linear-gradient(180deg, rgba(0,0,0,0.3), rgba(0,0,0,0.2));border-radius:14px;overflow:hidden;transform-origin:center center}
    .level-img-box{width:100%;height:clamp(120px,18vh,180px);background:#222;overflow:hidden}
    .level-img{width:100%;height:100%;object-fit:cover;display:block;transition:transform .6s ease}
    .level-info{padding:18px}

    /* interactive cursor */
    .cursor-dot,.cursor-outline{position:fixed;top:0;left:0;transform:translate(-50%,-50%);pointer-events:none;z-index:9999}
    .cursor-dot{width:8px;height:8px;background:var(--accent-acid);border-radius:50%;transition:transform .12s, background .12s}
    .cursor-outline{width:46px;height:46px;border-radius:50%;border:1px solid var(--accent-acid);transition:width .18s,height .18s,opacity .18s,transform .12s;opacity:0.95}
    .cursor-outline.grow{width:86px;height:86px;opacity:0.7}

    /* hover/tilt microinteraction */
    .level-card:hover .level-img{transform:scale(1.06)}

    /* responsive tweaks */
    @media (max-width:980px){
      .hero-inner{grid-template-columns:1fr}
      .grid-layout{grid-template-columns:1fr}
      .site-nav{top:12px}
    }

    @media (max-width:700px){
      .hero{padding:80px 16px}
      .level-img-box{height:clamp(100px,16vh,140px)}
      .big-x-mark{display:none}
    }
    /* hero zoom animation for click -> zoom -> manifesto */
    .hero.hero-zooming{transform-origin:center center;transition:transform .42s cubic-bezier(.2,.9,.2,1),filter .42s;transform:scale(1.04)}
    .hero.hero-zooming .hero-title{filter:blur(0.6px)}
    
    /* Print styles - 모든 콘텐츠 표시 */
    @media print{
      *{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}
      body{background:#fff !important;overflow:visible !important}
      .bg-video,.orb-container,.cursor-dot,.cursor-outline{display:none !important}
      .hero{page-break-after:always;min-height:auto;padding:40px 20px;position:relative !important}
      .toc-overlay,.present-overlay{position:relative !important;opacity:1 !important;display:block !important;background:transparent !important;page-break-after:always;z-index:auto !important}
      .toc-overlay .stage,.present-overlay .purpose-content-wrap{position:relative !important;max-width:100% !important;transform:none !important;opacity:1 !important;display:block !important}
      .toc-list li,.purpose-content-wrap,.artist-profile,.levels-grid{opacity:1 !important;transform:none !important;display:block !important}
      .toc-close,.present-close,.purpose-nav-buttons,.toc-print-btn{display:none !important}
      .purpose-content-wrap{page-break-inside:avoid;margin:20px 0}
      .purpose-section,.purpose-quote,.artist-profile-item{page-break-inside:avoid}
      img{max-width:100% !important;page-break-inside:avoid}
    }
  </style>
</head>
<body>
  <video class="bg-video" autoplay muted loop playsinline preload="auto">
    <source src="background.mp4" type="video/mp4">
    <source src="background.webm" type="video/webm">
    <!-- Fallback to image if video not supported -->
  </video>
  <div class="orb-container">
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>
    <div class="orb orb-3"></div>
  </div>

  <div class="cursor-dot" aria-hidden="true"></div>
  <div class="cursor-outline" aria-hidden="true"></div>

  <!-- top navigation removed -->

  <section class="hero">
    <div class="hero-title-wrapper">
      <h1 class="hero-title"><span class="hero-title-inner" data-text="XR Concert">XR Concert</span></h1>
      <div class="hero-subtitle">Unreal Engine Project</div>
    </div>
    <div style="margin-top:40px;z-index:2;font-family:var(--font-body);color:var(--accent-acid);">CLICK TO START</div>
  </section>

  <!-- Content below hero removed per request -->
</body>
<script>
// Helper function for debug logging (kept for debug mode)
function debugLog(location, message, data, hypothesisId = 'A') {
  fetch('http://127.0.0.1:7242/ingest/adde1938-5c03-4722-845b-a8d5d8f3bd1e',{
    method:'POST',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({
      location:location,
      message:message,
      data:data,
      timestamp:Date.now(),
      sessionId:'debug-session',
      runId:'run1',
      hypothesisId:hypothesisId
    })
  }).catch(()=>{});
}

// Global error handler for debugging
window.addEventListener('error', (e) => {
  debugLog(e.filename+':'+e.lineno, 'Global error', {
    error:e.message,
    stack:e.error?e.error.stack:'',
    filename:e.filename,
    lineno:e.lineno
  });
  console.error('Global error:', e);
});

window.addEventListener('unhandledrejection', (e) => {
  debugLog('unhandledrejection', 'Unhandled promise rejection', {
    error:e.reason?e.reason.toString():'unknown',
    stack:e.reason?e.reason.stack:'',
    promise:e.promise
  });
  console.error('Unhandled promise rejection:', e);
});

// Mantis-like interactivity: cursor, parallax and reveal-on-scroll
(function(){
  const cursorDot = document.querySelector('.cursor-dot');
  const cursorOutline = document.querySelector('.cursor-outline');
  const hoverTargets = document.querySelectorAll('.hover-target, a, button');

  let mouse = {x: window.innerWidth/2, y: window.innerHeight/2};
  let outlinePos = {x: mouse.x, y: mouse.y};

  // mouse move
  window.addEventListener('mousemove', (e)=>{
    mouse.x = e.clientX; mouse.y = e.clientY;
    cursorDot.style.transform = `translate(${mouse.x}px, ${mouse.y}px)`;
  });

  // simple lerped outline for smoothness
  function raf(){
    outlinePos.x += (mouse.x - outlinePos.x) * 0.18;
    outlinePos.y += (mouse.y - outlinePos.y) * 0.18;
    cursorOutline.style.transform = `translate(${outlinePos.x}px, ${outlinePos.y}px)`;
    requestAnimationFrame(raf);
  }
  raf();

  hoverTargets.forEach(el=>{
    el.addEventListener('mouseenter', ()=> cursorOutline.classList.add('grow'))
    el.addEventListener('mouseleave', ()=> cursorOutline.classList.remove('grow'))
  })

  // Parallax orbs on mouse move
  const orbs = document.querySelectorAll('.orb');
  window.addEventListener('mousemove', (e)=>{
    const cx = e.clientX - window.innerWidth/2;
    const cy = e.clientY - window.innerHeight/2;
    orbs.forEach((o, i)=>{
      const depth = (i+1) * 6; // different movement per orb
      o.style.transform = `translate(${cx/depth}px, ${cy/depth}px)`;
    });
  });

  // IntersectionObserver reveal
  const io = new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{
      if(entry.isIntersecting) entry.target.classList.add('visible');
      // optional: unobserve for performance
    })
  },{threshold:0.12});

  document.querySelectorAll('.section-padding, .grid-item, .level-card, .concept-box, .marker').forEach(el=>{
    el.classList.add('reveal'); io.observe(el);
  });

  // Big X reveal linked to scroll position
  const bigX = document.querySelector('.big-x-mark');
  if(bigX){
    const obs = new IntersectionObserver((entries)=>{
      entries.forEach(e=>{
        if(e.isIntersecting) bigX.classList.add('visible');
        else bigX.classList.remove('visible');
      })
    }, {threshold:0.2});
    obs.observe(bigX.parentElement || bigX);
  }

  // Presentation overlay setup (hero-triggered)
  // Hardcoded manifesto text used as the primary slide content so page can be minimal.
  const manifestoText = '그렇다면 언리얼 환경에서 단상이 있는 XR 콘서트를 구현할 필요가 있는가?';

  // Purpose content HTML
  const purposeContent = `
    <div class="purpose-content-wrap">
      <h2 class="purpose-title">Purpose</h2>
      <div class="purpose-content">
        <p>언리얼엔진으로 구현하는 XR콘서트의 목적</p>
        <p>언리얼 엔진은 실사 수준의 고품질 그래픽을 실시간으로 구현할 수 있는 리얼타임 3D 제작 플랫폼이다. 따라서 XR 콘서트에서 언리얼 엔진을 사용하는 주된 목적은 물리적 시공간의 제약을 넘어 사실적인 공간을 재현하고, 현실과 가상을 자연스럽게 융합하는 데 있다.</p>
          <div class="purpose-quote">그렇다면 언리얼 환경에서 단상이 있는 XR 콘서트를 구현할 필요가 있는가?</div>
          <p><strong style="color:var(--accent-acid);font-weight:800;">'X'라고 생각한다.</strong> 그 이유는 크게 두가지가 있다.</p>
        <div class="purpose-section">
          <div class="purpose-section-title">첫번째</div>
          <p>ICVFX(In-Camera VFX) 제작 환경의 기술적 특성이다. 리얼타임 렌더링을 전제로 할 때, 현재 대다수의 XR 콘서트는 <strong style="color:var(--accent-acid);font-weight:800;">ICVFX 방식</strong>을 채택하고 있다. 이러한 스튜디오 환경은 이미 바닥과 벽면이 거대한 <strong style="color:var(--accent-acid);font-weight:800;">LED 스크린으로 구성</strong>되어 있어, 공간 자체가 하나의 거대한 디지털 단상 역할을 수행하고 있다. 심지어 메인 조명 제어 또한 언리얼 엔진의 가상 환경이 아닌 실제 환경에서 운용되고 있다. 즉, 이미 스튜디오의 하드웨어 자체가 무대의 기능을 완벽히 대체하고 있으므로 별도의 가상의 단상은 불필요하다는 점을 알 수 있다.</p>
        </div>
        <div class="purpose-section">
          <div class="purpose-section-title">두번째</div>
          <p>XR 콘텐츠 소비자의 니즈(Needs)와 경험적 측면이다. XR 콘서트를 소비하는 관객은 대부분 <strong style="color:var(--accent-acid);font-weight:800;">HMD(헤드마운트 디스플레이)</strong>와 같은 몰입형 기기를 사용할 가능성이 높다. 이러한 사용자들은 현실에 존재하는 무대의 단순한 재현보다는, 현실에서는 경험할 수 없는 새로운 차원의 시각적 자극을 원한다. 따라서 현실의 물리적 제약을 상징하는 단상을 배치하는 것보다, <strong style="color:var(--accent-acid);font-weight:800;">가상의 무한한 가능성을 보여주는 것</strong>이 소비자가 원하는 콘텐츠의 본질에 더 부합한다고 볼 수 있다.</p>
        </div>
      </div>
      <div class="purpose-nav-buttons">
        <button class="purpose-nav-btn purpose-nav-prev" disabled style="opacity:0.3;">1. Purpose</button>
        <button class="purpose-nav-btn purpose-nav-next" data-next="project-strategy">2. Project Strategy</button>
      </div>
    </div>
  `;

  // Project Strategy content HTML
  const projectStrategyContent = `
    <div class="purpose-content-wrap project-strategy-wrap">
      <h2 class="purpose-title">Project Strategy</h2>
      <div class="purpose-content">
        <p>이러한 이유로 현실에서는 구현이 불가능하거나 물리적 제약으로 인해 표현하기 어려운 요소와 구성을 과감하게 반영하고자 했다.</p>
        <p style="margin-top:24px;">
          <a href="https://www.instagram.com/p/DFCkAR1ytkA/" target="_blank" rel="noopener noreferrer">참고 자료 보기 →</a><br>
          <a href="https://rollingstone.co.kr/main/$/21209" target="_blank" rel="noopener noreferrer" style="margin-top:12px;display:inline-block;">Rolling Stone Korea 기사 보기 →</a>
        </p>
        <div class="purpose-section">
          <p>이를 위해 프로젝트 내에 각기 다른 컨셉과 테마를 지닌 여러 레벨을 구축했다. 이는 마치 하나의 스튜디오 안에 다양한 세트장이 공존하는 것과 같은 시각적 다양성을 제공한다.</p>
          <p style="margin-top:24px;">또한, 작업 효율을 극대화하기 위해 에셋 제작 과정에 3D 생성형 AI를 적극 도입했다. 'Varco 3D' 프로그램을 활용하였으며, 이를 통해 제작한 주요 에셋은 다음과 같다.</p>
        </div>
        <p style="margin-top:48px;text-align:left;font-size:18px;color:#ffffff;font-weight:700;opacity:0.95;">[Varco 3D로 제작한 Asset]</p>
        <div class="purpose-image-grid asset-grid" style="margin-top:24px;">
          <img src="project-strategy-6.png" alt="XR 콘서트 에셋 이미지 6">
          <img src="project-strategy-7.png" alt="XR 콘서트 에셋 이미지 7">
          <img src="project-strategy-8.png" alt="XR 콘서트 에셋 이미지 8">
          <img src="project-strategy-9.png" alt="XR 콘서트 에셋 이미지 9">
          <img src="project-strategy-10.png" alt="XR 콘서트 에셋 이미지 10">
          <img src="project-strategy-11.png" alt="XR 콘서트 에셋 이미지 11">
          <img src="project-strategy-12.png" alt="XR 콘서트 에셋 이미지 12">
          <img src="project-strategy-13.png" alt="XR 콘서트 에셋 이미지 13">
          <img src="project-strategy-14.png" alt="XR 콘서트 에셋 이미지 14">
          <img src="project-strategy-15.png" alt="XR 콘서트 에셋 이미지 15">
        </div>
        <p style="margin-top:24px;"></p>
        <p style="margin-top:48px;text-align:left;font-size:18px;color:#ffffff;font-weight:700;opacity:0.95;">[참고한 XR 콘서트의 레퍼런스 & Scene 의 Mood]</p>
        <p style="margin-top:12px;text-align:left;font-size:14px;color:#ffffff;opacity:0.8;">#Openworld #XR #Concert #Dystopia #Fantasy</p>
        <div class="purpose-image-grid" style="margin-top:24px;">
          <img src="project-strategy-1.jpeg" alt="XR 콘서트 참고 이미지 1">
          <img src="project-strategy-2.jpeg" alt="XR 콘서트 참고 이미지 2">
          <img src="project-strategy-3.jpeg" alt="XR 콘서트 참고 이미지 3">
          <img src="project-strategy-4.jpeg" alt="XR 콘서트 참고 이미지 4">
          <img src="project-strategy-5.jpeg" alt="XR 콘서트 참고 이미지 5">
        </div>
      </div>
      <div class="purpose-nav-buttons">
        <button class="purpose-nav-btn purpose-nav-prev" data-prev="purpose">1. Purpose</button>
        <button class="purpose-nav-btn purpose-nav-next" data-next="artist">3. Artist</button>
      </div>
    </div>
  `;

  // Artist content HTML
  const artistContent = `
    <div class="purpose-content-wrap artist-wrap">
      <h2 class="purpose-title">Artist</h2>
      <div class="purpose-content">
        <p>아티스트 소개 및 콘서트 로그라인</p>
        <p>아티스트에 대한 조사를 한 뒤, 아티스트의 컨셉과 어울리는 콘서트 제작을 계획하였다.</p>
        <div class="purpose-section">
          <div class="purpose-section-title">아티스트 소개</div>
          <div class="artist-profile">
            <div class="artist-profile-image-wrapper">
              <img src="deantrbl-profile.webp" alt="딘(Dean) 프로필" class="artist-profile-image">
              <div class="artist-profile-name">딘(Dean)</div>
            </div>
            <div class="artist-profile-item">
              <div class="artist-profile-label">Genre</div>
              <div class="artist-profile-value">Alternative RnB, Future RnB</div>
            </div>
            <div class="artist-profile-item">
              <div class="artist-profile-label">Concept</div>
              <div class="artist-profile-value">Distopia / 신비주의 / 도시적인 / 몽환적인 <strong><1984></strong></div>
            </div>
            <div class="artist-profile-item">
              <div class="artist-profile-label">그 외 특징</div>
              <div class="artist-profile-value">#Deantrbl(Trouble) #Deanfluenza #권혁 #Producer #한국의 프랭크오션</div>
            </div>
            <a href="https://www.instagram.com/deantrbl/" target="_blank" rel="noopener noreferrer" class="artist-profile-link">Instagram 프로필 보기 →</a>
          </div>
        </div>
        <div class="purpose-quote-label">콘서트 로그라인</div>
        <div class="purpose-quote">무너져가는 디스토피아에서 불안정함을 노래하다.</div>
      </div>
      <div class="purpose-nav-buttons">
        <button class="purpose-nav-btn purpose-nav-prev" data-prev="project-strategy">2. Project Strategy</button>
        <button class="purpose-nav-btn purpose-nav-next" data-next="levels">4. Levels</button>
      </div>
    </div>
  `;

  // Levels content HTML
  const levelsContent = `
    <div class="purpose-content-wrap levels-wrap">
      <h2 class="purpose-title">Levels</h2>
      <div class="purpose-content">
        <p>노래에 어울리는 컨셉과 관련된 내용으로 레벨을 제작하였다.</p>
        <div class="levels-grid">
          <div class="level-content-card" data-level="howlin404" data-img="howlin404.jpg" data-video="howlin404.mp4">
            <div class="level-content-img-box">
              <div class="level-content-img" style="background:linear-gradient(135deg,rgba(139,69,19,0.6),rgba(75,0,130,0.6));display:flex;align-items:center;justify-content:center;color:var(--accent-acid);font-size:2rem;font-weight:700">Howlin' 404</div>
            </div>
            <div class="level-content-info">
              <div class="level-content-title">Howlin' 404</div>
              <div class="level-content-desc">디스토피아적인 공간에서 판타지적인 느낌과 약간의 그로테스크한 색감을 가져갔다.</div>
            </div>
          </div>
          <div class="level-content-card" data-level="nasa" data-img="nasa.jpg" data-video="nasa.mp4">
            <div class="level-content-img-box">
              <div class="level-content-img" style="background:linear-gradient(135deg,rgba(70,130,180,0.6),rgba(176,196,222,0.6));display:flex;align-items:center;justify-content:center;color:var(--accent-acid);font-size:2rem;font-weight:700">NASA</div>
            </div>
            <div class="level-content-info">
              <div class="level-content-title">NASA</div>
              <div class="level-content-desc">페허가 된 도시적인 공간에 눈이 내리는 감성적인 디스토피아 세계관을 제작하였다.</div>
            </div>
          </div>
          <div class="level-content-card" data-level="bonnieclyde" data-img="bonnieclyde.jpg" data-video="bonnieclyde.mp4">
            <div class="level-content-img-box">
              <div class="level-content-img" style="background:linear-gradient(135deg,rgba(139,69,19,0.6),rgba(160,82,45,0.6));display:flex;align-items:center;justify-content:center;color:var(--accent-acid);font-size:1.8rem;font-weight:700">Bonnie & Clyde</div>
            </div>
            <div class="level-content-info">
              <div class="level-content-title">Bonnie & Clyde</div>
              <div class="level-content-desc">무너져가는 건물을 두 개의 층으로 나눠 윗층을 빈티지적인, 아무도 드나들지 않은 페허가 된 공간으로 구성하였다.</div>
            </div>
          </div>
          <div class="level-content-card" data-level="nocturne07" data-img="nocturne07.jpg" data-video="nocturne07.mp4">
            <div class="level-content-img-box">
              <div class="level-content-img" style="background:linear-gradient(135deg,rgba(25,25,112,0.6),rgba(70,130,180,0.6));display:flex;align-items:center;justify-content:center;color:var(--accent-acid);font-size:1.8rem;font-weight:700">Nocturne 07</div>
            </div>
            <div class="level-content-info">
              <div class="level-content-title">Nocturne 07</div>
              <div class="level-content-desc">3번째의 레벨과 같은 건물의 마지막 공간으로, 아래층을 차가운 분위기의 수영장으로 구성하였다.</div>
            </div>
          </div>
        </div>
      </div>
      <div class="purpose-nav-buttons">
        <button class="purpose-nav-btn purpose-nav-prev" data-prev="artist">3. Artist</button>
        <button class="purpose-nav-btn purpose-nav-next" disabled style="opacity:0.3;">4. Levels</button>
      </div>
    </div>
  `;

  // Build overlay with controls and counter
  const overlay = document.createElement('div');
  overlay.className = 'present-overlay';
  overlay.innerHTML = `
    <div class="present-spotlight"></div>
    <div class="manifesto-present-wrap">
      <div class="manifesto-present-text"></div>
    </div>
    ${purposeContent}
    ${projectStrategyContent}
    ${artistContent}
    ${levelsContent}
    <div class="present-nav">
      <button class="present-btn prev" aria-label="Previous">◀</button>
      <button class="present-btn next" aria-label="Next">▶</button>
    </div>
    <button class="present-close" aria-label="Close presentation">Close ✕</button>
    <div class="present-counter" aria-hidden="true"></div>
    <div class="present-thumbs" aria-hidden="true"></div>
    <div class="present-progress"><div class="present-progress-fill"></div></div>
  `;
  document.body.appendChild(overlay);
  
  const purposeWrap = overlay.querySelector('.purpose-content-wrap:not(.project-strategy-wrap):not(.artist-wrap):not(.levels-wrap)');
  const projectStrategyWrap = overlay.querySelector('.project-strategy-wrap');
  const artistWrap = overlay.querySelector('.artist-wrap');
  const levelsWrap = overlay.querySelector('.levels-wrap');
  const manifestoWrap = overlay.querySelector('.manifesto-present-wrap');
  
  // Initially hide content
  if(purposeWrap) purposeWrap.style.display = 'none';
  if(projectStrategyWrap) projectStrategyWrap.style.display = 'none';
  if(artistWrap) artistWrap.style.display = 'none';
  if(levelsWrap) levelsWrap.style.display = 'none';
  
  // --- TOC overlay (stage + spotlights) ---
  const toc = document.createElement('div');
  toc.className = 'toc-overlay';
  toc.innerHTML = `
    <div class="stage">
      <div class="stage-spotlights">
        <div class="stage-spot left"></div>
        <div class="stage-spot center"></div>
        <div class="stage-spot right"></div>
      </div>
      <button class="toc-close" aria-label="Close contents">Close ✕</button>
      <ul class="toc-list" role="list">
        <li data-idx="0">1. Purpose</li>
        <li data-idx="1">2. Project Strategy</li>
        <li data-idx="2">3. Artist</li>
        <li data-idx="3">4. Levels</li>
      </ul>
      <button class="toc-print-btn" aria-label="PDF로 저장">📄 PDF로 저장</button>
    </div>
  `;
  document.body.appendChild(toc);
  const tocList = toc.querySelectorAll('.toc-list li');
  const tocClose = toc.querySelector('.toc-close');
  const tocPrintBtn = toc.querySelector('.toc-print-btn');

  function openToc(){
    toc.classList.add('open');
    document.body.classList.add('presenting');
    // Reset scroll to top only for the overlay content, not the page
    // The TOC overlay is fixed, so we don't need to reset window scroll
    const stage = toc.querySelector('.stage');
    if(stage) {
      stage.scrollTop = 0;
    }
    // Reset any scrollable content within TOC
    const tocListContainer = toc.querySelector('.toc-list');
    if(tocListContainer && tocListContainer.parentElement) {
      tocListContainer.parentElement.scrollTop = 0;
    }
    // stagger reveal
    tocList.forEach((li,i)=>{
      li.classList.remove('show');
      setTimeout(()=> li.classList.add('show'), 220 + i*140);
    });
  }
  function closeToc(){
    toc.classList.remove('open');
    document.body.classList.remove('presenting');
    tocList.forEach(li=> li.classList.remove('show'));
  }
  tocClose.addEventListener('click', closeToc);
  toc.addEventListener('click', (e)=>{ if(e.target === toc) closeToc(); });
  tocPrintBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    // PDF 파일을 브라우저에서 열기
    window.open('XR_Concert_Presentation.pdf', '_blank');
  });
  
  // Handle TOC item clicks
  tocList.forEach((li, index) => {
    li.addEventListener('click', (e) => {
      e.stopPropagation();
      if(index === 0) {
        // Purpose clicked
        currentMode = 'purpose';
        closeToc();
        setTimeout(() => {
          openPresent();
        }, 300);
      } else if(index === 1) {
        // Project Strategy clicked
        currentMode = 'project-strategy';
        closeToc();
        setTimeout(() => {
          openPresent();
        }, 300);
      } else if(index === 2) {
        // Artist clicked
        currentMode = 'artist';
        closeToc();
        setTimeout(() => {
          openPresent();
        }, 300);
      } else if(index === 3) {
        // Levels clicked
        currentMode = 'levels';
        closeToc();
        setTimeout(() => {
          openPresent();
        }, 300);
      } else {
        // Other items - can be extended later
        console.log('Clicked:', li.textContent);
      }
    });
  });

  // Spotlight effect that follows mouse cursor on TOC items
  // Dim other items when one is hovered
  tocList.forEach(li => {
    li.addEventListener('mouseenter', () => {
      // Dim all other items
      tocList.forEach(otherLi => {
        if(otherLi !== li) {
          otherLi.classList.add('dimmed');
        }
      });
    });
    
    li.addEventListener('mouseleave', () => {
      // Restore all items
      tocList.forEach(otherLi => {
        otherLi.classList.remove('dimmed');
      });
      // Reset spotlight to center when mouse leaves
      li.style.setProperty('--spotlight-x', '50%');
      li.style.setProperty('--spotlight-y', '50%');
      // Reset 3D transform
      li.style.transform = '';
    });
    
    li.addEventListener('mousemove', (e) => {
      const rect = li.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;
      
      // Calculate mouse position relative to center (-1 to 1)
      const mouseX = (x - centerX) / centerX;
      const mouseY = (y - centerY) / centerY;
      
      // Update spotlight position based on mouse position
      const offsetX = (x - centerX) * 0.3;
      const offsetY = (y - centerY) * 0.3;
      
      li.style.setProperty('--spotlight-x', `${50 + (offsetX / rect.width) * 100}%`);
      li.style.setProperty('--spotlight-y', `${50 + (offsetY / rect.height) * 100}%`);
      
      // 3D rotation based on mouse position (X, Y, Z-axis rotation)
      const rotateY = mouseX * 25; // -25 to 25 degrees (left-right tilt)
      const rotateX = -mouseY * 20; // -20 to 20 degrees (up-down tilt)
      const rotateZ = mouseX * 8 + mouseY * 5; // Z-axis rotation (combination of X and Y)
      const scale = 1.08 + Math.abs(mouseX) * 0.03 + Math.abs(mouseY) * 0.03;
      
      li.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) rotateZ(${rotateZ}deg) scale(${scale}) translateZ(30px)`;
    });
  });
  const presentText = overlay.querySelector('.manifesto-present-text');
  const closeBtn = overlay.querySelector('.present-close');
  const prevBtn = overlay.querySelector('.present-btn.prev');
  const nextBtn = overlay.querySelector('.present-btn.next');
  const counter = overlay.querySelector('.present-counter');

  // Customizable slides array — edit this list to change the presentation slides
  const SLIDES = [
    { title: 'Manifesto', content: manifestoText, thumb: 'Manifesto' }
  ];

  // small UI hooks
  const thumbs = overlay.querySelector('.present-thumbs');
  const progressFill = overlay.querySelector('.present-progress-fill');

  // populate thumbnails (clickable)
  SLIDES.forEach((s, i) => {
    const btn = document.createElement('button');
    btn.className = 'present-thumb';
    btn.type = 'button';
    btn.textContent = s.thumb || s.title || `Slide ${i+1}`;
    btn.addEventListener('click', (ev) => { ev.stopPropagation(); idx = i; render(); });
    thumbs.appendChild(btn);
  });

  let idx = 0;
  let currentMode = 'manifesto'; // 'manifesto', 'purpose', 'project-strategy', 'artist', or 'levels'
  
  // Helper function to reset scroll position for a content wrap
  function resetScrollPosition(wrap, titleSelector = '.purpose-title') {
    if(!wrap) return;
    
    wrap.scrollTop = 0;
    const title = wrap.querySelector(titleSelector);
    if(title) {
      title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
    }
    
    // Force scroll reset multiple times to ensure it sticks
    // CSS transition is 0.4s, so reset after transition completes
    requestAnimationFrame(() => {
      if(wrap) {
        wrap.scrollTop = 0;
        if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
        requestAnimationFrame(() => {
          if(wrap) {
            wrap.scrollTop = 0;
            if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
            // Reset after CSS transition completes (0.4s)
            setTimeout(() => {
              if(wrap) {
                wrap.scrollTop = 0;
                if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                // Final reset after another frame
                requestAnimationFrame(() => {
                  if(wrap) {
                    wrap.scrollTop = 0;
                    if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                  }
                });
              }
            }, 450);
          }
        });
      }
    });
  }
  
  // Helper function to show a section and hide others
  function showSection(activeWrap, currentMode) {
    // Hide all sections first
      if(manifestoWrap) manifestoWrap.style.display = 'none';
    if(purposeWrap) purposeWrap.style.display = 'none';
      if(projectStrategyWrap) projectStrategyWrap.style.display = 'none';
      if(artistWrap) artistWrap.style.display = 'none';
      if(levelsWrap) levelsWrap.style.display = 'none';
      if(counter) counter.style.display = 'none';
      if(thumbs) thumbs.style.display = 'none';
      if(prevBtn) prevBtn.style.display = 'none';
      if(nextBtn) nextBtn.style.display = 'none';
    
    // Reset scroll position to top for all sections before showing
    if(purposeWrap) purposeWrap.scrollTop = 0;
    if(projectStrategyWrap) projectStrategyWrap.scrollTop = 0;
    if(artistWrap) artistWrap.scrollTop = 0;
    if(levelsWrap) levelsWrap.scrollTop = 0;
    window.scrollTo({ top: 0, behavior: 'auto' });
    
    // Show active section
    if(activeWrap) {
      activeWrap.scrollTop = 0;
      activeWrap.style.display = 'block';
      
      // Ensure title is visible by scrolling to top and showing title
      const title = activeWrap.querySelector('.purpose-title');
      if(title) {
        // Reset scroll first
        activeWrap.scrollTop = 0;
        // Scroll title into view to ensure it's fully visible
        title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
        
        // Force multiple resets to ensure title is visible
        requestAnimationFrame(() => {
          if(activeWrap) {
            activeWrap.scrollTop = 0;
            if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
            requestAnimationFrame(() => {
              if(activeWrap) {
                activeWrap.scrollTop = 0;
                if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                // Reset after CSS transition completes
                setTimeout(() => {
                  if(activeWrap) {
                    activeWrap.scrollTop = 0;
                    if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                  }
                }, 450);
              }
            });
          }
        });
      } else {
        // Fallback to resetScrollPosition if title not found
        resetScrollPosition(activeWrap);
      }
      
      debugLog(`XR_1_bg.html:showSection`, `${currentMode} display set to block`, {
        scrollTop: activeWrap.scrollTop,
        display: activeWrap.style.display,
        hasTitle: !!title
      });
    }
  }
  
  // Helper function to safely observe elements with IntersectionObserver
  function observeElements(observer, elements, elementType = 'element') {
    if(!observer || !elements || elements.length === 0) return;
    
    elements.forEach((el, index) => {
      if(el && el.nodeType === 1) {
        try {
          observer.observe(el);
        } catch(e) {
          debugLog(`XR_1_bg.html:observeElements`, `Error observing ${elementType}`, {
            error: e.message,
            element: el.tagName || 'unknown',
            index: index
          });
          console.error(`Error observing ${elementType}:`, e, el);
        }
      }
    });
  }
  
  // Helper function to get active content wrap based on current mode
  function getActiveContent() {
    if(currentMode === 'purpose' && purposeWrap) return purposeWrap;
    else if(currentMode === 'project-strategy' && projectStrategyWrap) return projectStrategyWrap;
    else if(currentMode === 'artist' && artistWrap) return artistWrap;
    else if(currentMode === 'levels' && levelsWrap) return levelsWrap;
    return null;
  }
  
  function render(){
    debugLog('XR_1_bg.html:render', 'render() called', {currentMode:currentMode});
    
    // Reset all scroll positions first, before changing display
    if(purposeWrap) purposeWrap.scrollTop = 0;
    if(projectStrategyWrap) projectStrategyWrap.scrollTop = 0;
    if(artistWrap) artistWrap.scrollTop = 0;
    if(levelsWrap) levelsWrap.scrollTop = 0;
    
    if(currentMode === 'purpose'){
      showSection(purposeWrap, 'purpose');
    } else if(currentMode === 'project-strategy'){
      showSection(projectStrategyWrap, 'project-strategy');
    } else if(currentMode === 'artist'){
      showSection(artistWrap, 'artist');
    } else if(currentMode === 'levels'){
      showSection(levelsWrap, 'levels');
    } else {
      // Show manifesto content
      if(manifestoWrap) manifestoWrap.style.display = 'flex';
      if(purposeWrap) purposeWrap.style.display = 'none';
      if(projectStrategyWrap) projectStrategyWrap.style.display = 'none';
      if(artistWrap) artistWrap.style.display = 'none';
      if(levelsWrap) levelsWrap.style.display = 'none';
      if(counter) counter.style.display = 'block';
      if(thumbs) thumbs.style.display = 'flex';
      if(prevBtn) prevBtn.style.display = 'block';
      if(nextBtn) nextBtn.style.display = 'block';
      
    const slide = SLIDES[idx] || { content: '' };
      if(presentText) presentText.textContent = slide.content || '';
      if(counter) counter.textContent = `${idx+1} / ${SLIDES.length}`;
    const pct = ((idx+1) / SLIDES.length) * 100;
      if(progressFill) progressFill.style.width = pct + '%';
    // active thumb
      if(thumbs) thumbs.querySelectorAll('.present-thumb').forEach((t, ti)=> t.classList.toggle('active', ti === idx));
    }
  }

  function openPresent(){
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/adde1938-5c03-4722-845b-a8d5d8f3bd1e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'XR_1_bg.html:874',message:'openPresent() called',data:{currentMode:currentMode},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
    // #endregion
    overlay.classList.add('open');
    document.documentElement.style.scrollBehavior = 'auto';
    document.body.style.overflow = 'hidden';
    document.body.classList.add('presenting');
    render();
    
    // Scroll to top immediately
    const activeContent = getActiveContent();
    
    if(activeContent) debugLog('XR_1_bg.html:openPresent', 'Before setting scrollTop to 0', {
      currentMode:currentMode,
      scrollTop:activeContent.scrollTop,
      display:activeContent.style.display
    }, 'D');
    
    if(activeContent){
      activeContent.scrollTop = 0;
      
      // Ensure title is visible
      const title = activeContent.querySelector('.purpose-title');
      if(title) {
        title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
      }
      
      // Force scroll reset using requestAnimationFrame to ensure it happens after render
      requestAnimationFrame(() => {
        if(activeContent) {
          activeContent.scrollTop = 0;
          if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
          requestAnimationFrame(() => {
            if(activeContent) {
              activeContent.scrollTop = 0;
              if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
              // Additional reset after a short delay to ensure it sticks
              setTimeout(() => {
                if(activeContent) {
                  activeContent.scrollTop = 0;
                  if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                }
              }, 100);
            }
          });
        }
      });
    }
    if(activeContent) debugLog('XR_1_bg.html:openPresent', 'After setting scrollTop to 0', {
      currentMode:currentMode,
      scrollTop:activeContent.scrollTop
    }, 'D');
    window.scrollTo({ top: 0, behavior: 'auto' });
    
    // Setup scroll-based animations for Purpose content
    if(currentMode === 'purpose' && purposeWrap){
      setTimeout(() => {
        // #region agent log
        if(purposeWrap) fetch('http://127.0.0.1:7242/ingest/adde1938-5c03-4722-845b-a8d5d8f3bd1e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'XR_1_bg.html:895',message:'Before setupPurposeScrollAnimations',data:{scrollTop:purposeWrap.scrollTop},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
        setupPurposeScrollAnimations();
        // Ensure scroll is at top and title is visible after animation setup
        if(purposeWrap) {
          purposeWrap.scrollTop = 0;
          const title = purposeWrap.querySelector('.purpose-title');
          if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
          requestAnimationFrame(() => {
            if(purposeWrap) {
              purposeWrap.scrollTop = 0;
              if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
            }
          });
        }
        if(purposeWrap) debugLog('XR_1_bg.html:openPresent', 'After setupPurposeScrollAnimations and scrollTop reset', {
          scrollTop:purposeWrap.scrollTop
        }, 'E');
      }, 400);
    }
    
    // Setup scroll-based animations for Project Strategy content
    if(currentMode === 'project-strategy' && projectStrategyWrap){
      setTimeout(() => {
        setupPurposeScrollAnimations(projectStrategyWrap);
        // Ensure scroll is at top and title is visible after animation setup
        if(projectStrategyWrap) {
          projectStrategyWrap.scrollTop = 0;
          const title = projectStrategyWrap.querySelector('.purpose-title');
          if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
          requestAnimationFrame(() => {
            if(projectStrategyWrap) {
              projectStrategyWrap.scrollTop = 0;
              if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
            }
          });
        }
      }, 400);
    }
    
    // Setup scroll-based animations for Artist content
    if(currentMode === 'artist' && artistWrap){
      setTimeout(() => {
        setupPurposeScrollAnimations(artistWrap);
        // Ensure scroll is at top and title is visible after animation setup
        if(artistWrap) {
          artistWrap.scrollTop = 0;
          const title = artistWrap.querySelector('.purpose-title');
          if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
          requestAnimationFrame(() => {
            if(artistWrap) {
              artistWrap.scrollTop = 0;
              if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
            }
          });
        }
      }, 400);
    }
    
    // Setup scroll-based animations for Levels content
    if(currentMode === 'levels' && levelsWrap){
      setTimeout(() => {
        setupLevelsScrollAnimations();
        // Ensure scroll is at top and title is visible after animation setup
        if(levelsWrap) {
          levelsWrap.scrollTop = 0;
          const title = levelsWrap.querySelector('.purpose-title');
          if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
          requestAnimationFrame(() => {
            if(levelsWrap) {
              levelsWrap.scrollTop = 0;
              if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
            }
          });
        }
      }, 400);
    }
  }
  
  function setupPurposeScrollAnimations(targetWrap = purposeWrap){
    debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'setupPurposeScrollAnimations called', {
      targetWrap:targetWrap?targetWrap.className:'null',
      hasTargetWrap:!!targetWrap,
      hasPurposeWrap:!!purposeWrap
    });
    try {
    debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Before contentWrap assignment', {
      targetWrap:targetWrap?targetWrap.className:'null',
      hasTargetWrap:!!targetWrap,
      targetWrapType:targetWrap?typeof targetWrap:'null',
      targetWrapNodeType:targetWrap?targetWrap.nodeType:'null',
      purposeWrap:purposeWrap?purposeWrap.className:'null',
      hasPurposeWrap:!!purposeWrap,
      purposeWrapType:purposeWrap?typeof purposeWrap:'null',
      purposeWrapNodeType:purposeWrap?purposeWrap.nodeType:'null'
    });
    
    // Validate targetWrap and purposeWrap before assignment
    let contentWrap = null;
    if(targetWrap && targetWrap.nodeType === 1) {
      contentWrap = targetWrap;
      debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Using targetWrap for contentWrap', {
        targetWrap:targetWrap.className
      });
    } else if(purposeWrap && purposeWrap.nodeType === 1) {
      contentWrap = purposeWrap;
      debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Using purposeWrap for contentWrap', {
        purposeWrap:purposeWrap.className
      });
    } else {
      debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Neither targetWrap nor purposeWrap is valid', {
        targetWrap:targetWrap?targetWrap.className:'null',
        targetWrapValid:targetWrap&&targetWrap.nodeType===1,
        purposeWrap:purposeWrap?purposeWrap.className:'null',
        purposeWrapValid:purposeWrap&&purposeWrap.nodeType===1
      });
    }
    
    debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'After contentWrap assignment', {
      contentWrap:contentWrap?contentWrap.className:'null',
      hasContentWrap:!!contentWrap,
      contentWrapType:contentWrap?typeof contentWrap:'null',
      contentWrapNodeType:contentWrap?contentWrap.nodeType:'null',
      usedTargetWrap:contentWrap===targetWrap,
      usedPurposeWrap:contentWrap===purposeWrap
    });
    
    if(!contentWrap) {
      debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'contentWrap is null or undefined', {
        targetWrap:targetWrap?targetWrap.className:'null',
        purposeWrap:purposeWrap?purposeWrap.className:'null'
      });
      console.error('setupPurposeScrollAnimations: contentWrap is null or undefined');
      console.error('targetWrap:', targetWrap);
      console.error('purposeWrap:', purposeWrap);
      return;
    }
    
    debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Before querySelector for purpose-content', {
      contentWrap:contentWrap?contentWrap.className:'null',
      contentWrapExists:!!contentWrap,
      contentWrapTagName:contentWrap?contentWrap.tagName:'null',
      contentWrapInnerHTML:contentWrap?contentWrap.innerHTML.substring(0,200):'null'
    });
    
    let purposeContent = null;
    try {
      purposeContent = contentWrap.querySelector('.purpose-content');
    } catch(e) {
      debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Error in querySelector for purpose-content', {
        error:e.message,
        stack:e.stack,
        contentWrap:contentWrap?contentWrap.className:'null'
      });
      console.error('Error in querySelector for .purpose-content:', e, contentWrap);
      return;
    }
    
    if(!purposeContent) debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'purposeContent not found', {
      contentWrap:contentWrap?contentWrap.className:'null',
      contentWrapExists:!!contentWrap,
      queryResult:null,
      allChildren:contentWrap?Array.from(contentWrap.children).map(c=>c.className).join(','):'null'
    });
    
    if(!purposeContent) {
      console.error('setupPurposeScrollAnimations: .purpose-content element not found in contentWrap');
      console.error('contentWrap:', contentWrap);
      console.error('contentWrap children:', contentWrap ? Array.from(contentWrap.children) : 'null');
      return;
    }
    
    // Reset all animations - remove visible classes and scrolled class
    contentWrap.classList.remove('scrolled');
    const allAnimatedElements = contentWrap.querySelectorAll('.visible, [class*="visible"]');
    allAnimatedElements.forEach(el => {
      el.classList.remove('visible');
    });
    
    // Reset title, paragraphs, sections, images, etc.
    const title = contentWrap.querySelector('.purpose-title');
    let paragraphs = purposeContent.querySelectorAll('p');
    let sections = purposeContent.querySelectorAll('.purpose-section');
    let imageGrids = purposeContent.querySelectorAll('.purpose-image-grid');
    let images = purposeContent.querySelectorAll('img');
    let navButtons = contentWrap.querySelector('.purpose-nav-buttons');
    
    debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Before removing visible classes', {
      title:!!title,
      paragraphsCount:paragraphs?paragraphs.length:0,
      sectionsCount:sections?sections.length:0,
      imageGridsCount:imageGrids?imageGrids.length:0,
      imagesCount:images?images.length:0,
      navButtons:!!navButtons
    });
    
    // Safely remove visible classes from all elements
    const elementsToReset = [];
    if(title) elementsToReset.push(title);
    if(paragraphs && paragraphs.length > 0) elementsToReset.push(...Array.from(paragraphs));
    if(sections && sections.length > 0) elementsToReset.push(...Array.from(sections));
    if(imageGrids && imageGrids.length > 0) elementsToReset.push(...Array.from(imageGrids));
    if(images && images.length > 0) elementsToReset.push(...Array.from(images));
    if(navButtons) elementsToReset.push(navButtons);
    
    elementsToReset.forEach(el => {
      if(el && el.nodeType === 1) { // Check if el is a valid element node
        try {
          el.classList.remove('visible');
        } catch(e) {
          debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Error removing visible class', {
            error:e.message,
            element:el?el.tagName:'null'
          });
          console.error('Error removing visible class:', e, el);
        }
      }
    });
    
    // Animate title first
    debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Before animating title', {
      title:!!title,
      titleElement:title?title.tagName:'null',
      contentWrap:!!contentWrap,
      contentWrapElement:contentWrap?contentWrap.className:'null'
    });
    
    if(title && contentWrap){
      setTimeout(() => {
        if(contentWrap) {
          try {
        contentWrap.classList.add('scrolled');
            debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Added scrolled class', {
              contentWrap:contentWrap.className,
              hasScrolledClass:contentWrap.classList.contains('scrolled')
            });
          } catch(e) {
            debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Error adding scrolled class', {
              error:e.message,
              stack:e.stack,
              contentWrap:contentWrap?contentWrap.className:'null'
            });
            console.error('Error adding scrolled class:', e, contentWrap);
          }
        }
      }, 200);
    } else {
      debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Title or contentWrap is null, skipping animation', {
        title:!!title,
        contentWrap:!!contentWrap
      });
    }
    
    // Disconnect previous observer if exists
    if(contentWrap._scrollObserver){
      try {
        contentWrap._scrollObserver.disconnect();
      } catch(e) {
        // Observer may already be disconnected, ignore error
      }
      contentWrap._scrollObserver = null;
    }
    
    // Setup IntersectionObserver for scroll-triggered animations
    const observerOptions = {
      threshold: 0.2,
      rootMargin: '0px 0px -50px 0px'
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry, index) => {
        if(entry.isIntersecting){
          setTimeout(() => {
            entry.target.classList.add('visible');
          }, index * 150); // Stagger animations
        }
      });
    }, observerOptions);
    
    // Store observer reference for cleanup
    contentWrap._scrollObserver = observer;
    
    debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Before observing elements', {
      paragraphsCount:paragraphs?paragraphs.length:0,
      observerExists:!!observer
    });
    
    // Observe paragraphs, image grids, and images using helper function
    observeElements(observer, paragraphs, 'paragraph');
    observeElements(observer, imageGrids, 'image grid');
    observeElements(observer, images, 'image');
    
    // Observe quote label
    const quoteLabels = purposeContent.querySelectorAll('.purpose-quote-label');
    observeElements(observer, quoteLabels, 'quote label');
    
    // Observe quote (special attention)
    const quote = purposeContent.querySelector('.purpose-quote');
    if(quote){
      // Disconnect previous quoteObserver if exists
      if(quote._quoteObserver){
        try {
          quote._quoteObserver.disconnect();
        } catch(e) {
          // Observer may already be disconnected, ignore error
        }
        quote._quoteObserver = null;
      }
      
      const quoteObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if(entry.isIntersecting){
            setTimeout(() => {
              entry.target.classList.add('visible');
              // Add extra attention with sound-like visual feedback
              const ripple = document.createElement('div');
              ripple.style.cssText = 'position:absolute;inset:-10px;border:2px solid var(--accent-acid);border-radius:12px;opacity:0.6;animation:ripple-out 1.5s ease-out';
              quote.appendChild(ripple);
              setTimeout(() => ripple.remove(), 1500);
            }, 300);
          }
        });
      }, { threshold: 0.3 });
      
      // Store observer reference for cleanup
      quote._quoteObserver = quoteObserver;
      quoteObserver.observe(quote);
    }
    
    // Observe artist profile and sections using helper function
    const artistProfiles = purposeContent.querySelectorAll('.artist-profile');
    observeElements(observer, artistProfiles, 'artist profile');
    observeElements(observer, sections, 'section');
    
    // Observe navigation buttons
    if(navButtons){
      debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Setting up nav buttons', {
        hasNavButtons:!!navButtons
      });
      
      // Disconnect previous btnObserver if exists
      if(navButtons._btnObserver){
        try {
          navButtons._btnObserver.disconnect();
        } catch(e) {
          // Observer may already be disconnected, ignore error
        }
        navButtons._btnObserver = null;
      }
      
      const btnObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if(entry.isIntersecting){
            setTimeout(() => {
              entry.target.classList.add('visible');
            }, 200);
          }
        });
      }, { threshold: 0.5 });
      
      // Store observer reference for cleanup
      navButtons._btnObserver = btnObserver;
      btnObserver.observe(navButtons);
      
      // Add interactive effects to all nav buttons
      const navBtns = navButtons.querySelectorAll('.purpose-nav-btn:not(:disabled)');
      navBtns.forEach(btn => {
        // Remove existing mousemove listeners if any
        if(btn._mousemoveHandler) {
          try {
            btn.removeEventListener('mousemove', btn._mousemoveHandler);
          } catch(e) {
            // Ignore errors if handler was already removed
          }
          btn._mousemoveHandler = null;
        }
        if(btn._mouseleaveHandler) {
          try {
            btn.removeEventListener('mouseleave', btn._mouseleaveHandler);
          } catch(e) {
            // Ignore errors if handler was already removed
          }
          btn._mouseleaveHandler = null;
        }
      
      // Add same interactive effects as TOC items
        const mousemoveHandler = (e) => {
          const rect = btn.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        // Calculate mouse position relative to center (-1 to 1)
        const mouseX = (x - centerX) / centerX;
        const mouseY = (y - centerY) / centerY;
        
        // Update spotlight position based on mouse position
        const offsetX = (x - centerX) * 0.3;
        const offsetY = (y - centerY) * 0.3;
        
          btn.style.setProperty('--spotlight-x', `${50 + (offsetX / rect.width) * 100}%`);
          btn.style.setProperty('--spotlight-y', `${50 + (offsetY / rect.height) * 100}%`);
        
        // 3D rotation based on mouse position (X, Y, Z-axis rotation)
        const rotateY = mouseX * 25; // -25 to 25 degrees (left-right tilt)
        const rotateX = -mouseY * 20; // -20 to 20 degrees (up-down tilt)
        const rotateZ = mouseX * 8 + mouseY * 5; // Z-axis rotation (combination of X and Y)
        const scale = 1.08 + Math.abs(mouseX) * 0.03 + Math.abs(mouseY) * 0.03;
        
          btn.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) rotateZ(${rotateZ}deg) scale(${scale}) translateZ(30px)`;
        };
      
        const mouseleaveHandler = () => {
        // Reset spotlight to center when mouse leaves
          btn.style.setProperty('--spotlight-x', '50%');
          btn.style.setProperty('--spotlight-y', '50%');
        // Reset 3D transform
          btn.style.transform = '';
        };
        
        btn._mousemoveHandler = mousemoveHandler;
        btn._mouseleaveHandler = mouseleaveHandler;
        btn.addEventListener('mousemove', mousemoveHandler);
        btn.addEventListener('mouseleave', mouseleaveHandler);
      });
      
      // Click handlers for prev/next buttons
      const prevBtn = navButtons.querySelector('.purpose-nav-prev:not(:disabled)');
      const nextBtn = navButtons.querySelector('.purpose-nav-next:not(:disabled)');
      
      // Remove existing click listeners if any
      if(prevBtn && prevBtn._clickHandler){
        try {
          prevBtn.removeEventListener('click', prevBtn._clickHandler);
        } catch(e) {
          // Ignore errors if handler was already removed
        }
        prevBtn._clickHandler = null;
      }
      if(nextBtn && nextBtn._clickHandler){
        try {
          nextBtn.removeEventListener('click', nextBtn._clickHandler);
        } catch(e) {
          // Ignore errors if handler was already removed
        }
        nextBtn._clickHandler = null;
      }
      
      if(prevBtn && prevBtn.dataset.prev){
        const clickHandler = (e) => {
        e.stopPropagation();
          const targetMode = prevBtn.dataset.prev;
          debugLog('XR_1_bg.html:prevBtn', 'prevBtn clicked', {
            currentMode:currentMode,
            targetMode:targetMode
          });
          closePresent();
          setTimeout(() => {
            currentMode = targetMode;
            const activeContentBefore = getActiveContent();
            debugLog('XR_1_bg.html:prevBtn', 'Before openPresent() in prevBtn handler', {
              currentMode:currentMode,
              activeContentScrollTop:activeContentBefore?activeContentBefore.scrollTop:0
            }, 'B');
            openPresent();
            // Scroll to top after opening
          setTimeout(() => {
              const activeContent = getActiveContent();
              debugLog('XR_1_bg.html:prevBtn', 'In prevBtn setTimeout callback', {
                currentMode:currentMode,
                scrollTop:activeContent?activeContent.scrollTop:0
              }, 'E');
              
              if(activeContent){
                activeContent.scrollTop = 0;
                const title = activeContent.querySelector('.purpose-title');
                if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                requestAnimationFrame(() => {
                  if(activeContent) {
                    activeContent.scrollTop = 0;
                    if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                  }
                });
              }
              debugLog('XR_1_bg.html:prevBtn', 'After setting scrollTop in prevBtn callback', {
                scrollTop:activeContent?activeContent.scrollTop:0
              }, 'E');
              window.scrollTo({ top: 0, behavior: 'auto' });
            }, 100);
          }, 300);
        };
        
        prevBtn._clickHandler = clickHandler;
        prevBtn.addEventListener('click', clickHandler);
      }
      
      if(nextBtn && nextBtn.dataset.next){
        const clickHandler = (e) => {
          e.stopPropagation();
          const targetMode = nextBtn.dataset.next;
          closePresent();
          setTimeout(() => {
            currentMode = targetMode;
            openPresent();
            // Scroll to top after opening and ensure title is visible
            setTimeout(() => {
              const activeContent = getActiveContent();
              if(activeContent){
                activeContent.scrollTop = 0;
                const title = activeContent.querySelector('.purpose-title');
                if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                requestAnimationFrame(() => {
                  if(activeContent) {
                    activeContent.scrollTop = 0;
                    if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                  }
                });
              }
              window.scrollTo({ top: 0, behavior: 'auto' });
            }, 100);
          }, 300);
        };
        
        nextBtn._clickHandler = clickHandler;
        nextBtn.addEventListener('click', clickHandler);
        }
    }
    
    // Add ripple animation for quote
    if(!document.querySelector('#purpose-ripple-style')){
      const style = document.createElement('style');
      style.id = 'purpose-ripple-style';
      style.textContent = `
        @keyframes ripple-out {
          0% { transform: scale(0.8); opacity: 0.6; }
          100% { transform: scale(1.5); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }
    } catch(error) {
      debugLog('XR_1_bg.html:setupPurposeScrollAnimations', 'Error in setupPurposeScrollAnimations', {
        error:error.message,
        stack:error.stack,
        name:error.name,
        targetWrap:targetWrap?targetWrap.className:'null'
      });
      console.error('Error in setupPurposeScrollAnimations:', error);
      // Re-throw to see in console
      throw error;
    }
  }
  
  function setupLevelsScrollAnimations(){
    if(!levelsWrap) return;
    
    try {
    const levelsGrid = levelsWrap.querySelector('.levels-grid');
    if(!levelsGrid) return;
    
    // Reset all animations - remove visible classes and scrolled class
    levelsWrap.classList.remove('scrolled');
    const allAnimatedElements = levelsWrap.querySelectorAll('.visible, [class*="visible"]');
    allAnimatedElements.forEach(el => {
      el.classList.remove('visible');
    });
    
    // Reset title and cards
    const title = levelsWrap.querySelector('.purpose-title');
    let cards = levelsGrid.querySelectorAll('.level-content-card');
    
    if(title) title.classList.remove('visible');
    cards.forEach(card => card.classList.remove('visible'));
    if(levelsGrid) levelsGrid.classList.remove('visible');
    
    // Animate title first
    if(title){
      setTimeout(() => {
        levelsWrap.classList.add('scrolled');
      }, 200);
    }
    
    // Disconnect previous observer if exists
    if(levelsWrap._levelsObserver){
      try {
        levelsWrap._levelsObserver.disconnect();
      } catch(e) {
        // Observer may already be disconnected, ignore error
      }
      levelsWrap._levelsObserver = null;
    }
    
    // Setup IntersectionObserver for cards
    const observerOptions = {
      threshold: 0.2,
      rootMargin: '0px 0px -50px 0px'
    };
    
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry, index) => {
        if(entry.isIntersecting){
          setTimeout(() => {
            entry.target.classList.add('visible');
          }, index * 150); // Stagger animations
        }
      });
    }, observerOptions);
    
    // Store observer reference for cleanup
    levelsWrap._levelsObserver = observer;
    
    // Observe grid
    observer.observe(levelsGrid);
    
    // Observe individual cards
    cards.forEach(card => {
      observer.observe(card);
      
      // Remove existing listeners if any
      if(card._mousemoveHandler) {
        try {
          card.removeEventListener('mousemove', card._mousemoveHandler);
        } catch(e) {
          // Ignore errors if handler was already removed
        }
        card._mousemoveHandler = null;
      }
      if(card._mouseleaveHandler) {
        try {
          card.removeEventListener('mouseleave', card._mouseleaveHandler);
        } catch(e) {
          // Ignore errors if handler was already removed
        }
        card._mouseleaveHandler = null;
      }
      
      // Remove existing click handler if any
      if(card._clickHandler) {
        try {
          card.removeEventListener('click', card._clickHandler);
        } catch(e) {
          // Ignore errors if handler was already removed
        }
        card._clickHandler = null;
      }
      
      // Add TOC-like hover effects (spotlight and 3D rotation)
      const mousemoveHandler = (e) => {
        const rect = card.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const centerX = rect.width / 2;
        const centerY = rect.height / 2;
        
        // Calculate mouse position relative to center (-1 to 1)
        const mouseX = (x - centerX) / centerX;
        const mouseY = (y - centerY) / centerY;
        
        // Update spotlight position based on mouse position
        const offsetX = (x - centerX) * 0.3;
        const offsetY = (y - centerY) * 0.3;
        
        card.style.setProperty('--spotlight-x', `${50 + (offsetX / rect.width) * 100}%`);
        card.style.setProperty('--spotlight-y', `${50 + (offsetY / rect.height) * 100}%`);
        
        // 3D rotation based on mouse position (X, Y, Z-axis rotation)
        const rotateY = mouseX * 15; // -15 to 15 degrees (left-right tilt)
        const rotateX = -mouseY * 12; // -12 to 12 degrees (up-down tilt)
        const rotateZ = mouseX * 5 + mouseY * 3; // Z-axis rotation
        const scale = 1.02 + Math.abs(mouseX) * 0.02 + Math.abs(mouseY) * 0.02;
        
        card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) rotateZ(${rotateZ}deg) scale(${scale}) translateZ(20px)`;
      };
      
      const mouseleaveHandler = () => {
        // Reset spotlight to center when mouse leaves
        card.style.setProperty('--spotlight-x', '50%');
        card.style.setProperty('--spotlight-y', '50%');
        // Reset 3D transform
        card.style.transform = '';
      };
      
      // Click handler - open media modal
      const clickHandler = () => {
        openLevelMediaModal(card);
      };
      
      card._mousemoveHandler = mousemoveHandler;
      card._mouseleaveHandler = mouseleaveHandler;
      card._clickHandler = clickHandler;
      card.addEventListener('mousemove', mousemoveHandler);
      card.addEventListener('mouseleave', mouseleaveHandler);
      card.addEventListener('click', clickHandler);
    });
    
    // Observe paragraphs
    const paragraphs = levelsWrap.querySelectorAll('.purpose-content p');
    observeElements(observer, paragraphs, 'paragraph');
    
    // Observe navigation buttons
    const navButtons = levelsWrap.querySelector('.purpose-nav-buttons');
    if(navButtons){
      // Disconnect previous btnObserver if exists
      if(navButtons._btnObserver){
        try {
          navButtons._btnObserver.disconnect();
        } catch(e) {
          // Observer may already be disconnected, ignore error
        }
        navButtons._btnObserver = null;
      }
      
      const btnObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if(entry.isIntersecting){
            setTimeout(() => {
              entry.target.classList.add('visible');
            }, 200);
          }
        });
      }, { threshold: 0.5 });
      
      // Store observer reference for cleanup
      navButtons._btnObserver = btnObserver;
      btnObserver.observe(navButtons);
      
      // Add interactive effects to all nav buttons
      const navBtns = navButtons.querySelectorAll('.purpose-nav-btn:not(:disabled)');
      navBtns.forEach(btn => {
        // Remove existing listeners if any
        if(btn._mousemoveHandler) btn.removeEventListener('mousemove', btn._mousemoveHandler);
        if(btn._mouseleaveHandler) btn.removeEventListener('mouseleave', btn._mouseleaveHandler);
        
        // Add same interactive effects as TOC items
        const mousemoveHandler = (e) => {
          const rect = btn.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          // Calculate mouse position relative to center (-1 to 1)
          const mouseX = (x - centerX) / centerX;
          const mouseY = (y - centerY) / centerY;
          
          // Update spotlight position based on mouse position
          const offsetX = (x - centerX) * 0.3;
          const offsetY = (y - centerY) * 0.3;
          
          btn.style.setProperty('--spotlight-x', `${50 + (offsetX / rect.width) * 100}%`);
          btn.style.setProperty('--spotlight-y', `${50 + (offsetY / rect.height) * 100}%`);
          
          // 3D rotation based on mouse position (X, Y, Z-axis rotation)
          const rotateY = mouseX * 25; // -25 to 25 degrees (left-right tilt)
          const rotateX = -mouseY * 20; // -20 to 20 degrees (up-down tilt)
          const rotateZ = mouseX * 8 + mouseY * 5; // Z-axis rotation (combination of X and Y)
          const scale = 1.08 + Math.abs(mouseX) * 0.03 + Math.abs(mouseY) * 0.03;
          
          btn.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) rotateZ(${rotateZ}deg) scale(${scale}) translateZ(30px)`;
        };
        
        const mouseleaveHandler = () => {
          // Reset spotlight to center when mouse leaves
          btn.style.setProperty('--spotlight-x', '50%');
          btn.style.setProperty('--spotlight-y', '50%');
          // Reset 3D transform
          btn.style.transform = '';
        };
        
        btn._mousemoveHandler = mousemoveHandler;
        btn._mouseleaveHandler = mouseleaveHandler;
        btn.addEventListener('mousemove', mousemoveHandler);
        btn.addEventListener('mouseleave', mouseleaveHandler);
      });
      
      // Click handlers for prev/next buttons
      const prevBtn = navButtons.querySelector('.purpose-nav-prev:not(:disabled)');
      const nextBtn = navButtons.querySelector('.purpose-nav-next:not(:disabled)');
      
      // Remove existing click listeners if any
      if(prevBtn && prevBtn._clickHandler){
        try {
          prevBtn.removeEventListener('click', prevBtn._clickHandler);
        } catch(e) {
          // Ignore errors if handler was already removed
        }
        prevBtn._clickHandler = null;
      }
      if(nextBtn && nextBtn._clickHandler){
        try {
          nextBtn.removeEventListener('click', nextBtn._clickHandler);
        } catch(e) {
          // Ignore errors if handler was already removed
        }
        nextBtn._clickHandler = null;
      }
      
      if(prevBtn && prevBtn.dataset.prev){
        const clickHandler = (e) => {
          e.stopPropagation();
          const targetMode = prevBtn.dataset.prev;
          closePresent();
          setTimeout(() => {
            currentMode = targetMode;
            openPresent();
            // Scroll to top after opening and ensure title is visible
            setTimeout(() => {
              const activeContent = getActiveContent();
              if(activeContent){
                activeContent.scrollTop = 0;
                const title = activeContent.querySelector('.purpose-title');
                if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                requestAnimationFrame(() => {
                  if(activeContent) {
                    activeContent.scrollTop = 0;
                    if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                  }
                });
              }
              window.scrollTo({ top: 0, behavior: 'auto' });
            }, 100);
          }, 300);
        };
        
        prevBtn._clickHandler = clickHandler;
        prevBtn.addEventListener('click', clickHandler);
      }
      
      if(nextBtn && nextBtn.dataset.next){
        const clickHandler = (e) => {
          e.stopPropagation();
          const targetMode = nextBtn.dataset.next;
          closePresent();
          setTimeout(() => {
            currentMode = targetMode;
            openPresent();
            // Scroll to top after opening and ensure title is visible
            setTimeout(() => {
              const activeContent = getActiveContent();
              if(activeContent){
                activeContent.scrollTop = 0;
                const title = activeContent.querySelector('.purpose-title');
                if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                requestAnimationFrame(() => {
                  if(activeContent) {
                    activeContent.scrollTop = 0;
                    if(title) title.scrollIntoView({ behavior: 'auto', block: 'start', inline: 'nearest' });
                  }
                });
              }
              window.scrollTo({ top: 0, behavior: 'auto' });
            }, 100);
          }, 300);
        };
        
        nextBtn._clickHandler = clickHandler;
        nextBtn.addEventListener('click', clickHandler);
      }
    }
    } catch(error) {
      debugLog('XR_1_bg.html:setupLevelsScrollAnimations', 'Error in setupLevelsScrollAnimations', {
        error:error.message,
        stack:error.stack
      });
      console.error('Error in setupLevelsScrollAnimations:', error);
      throw error;
    }
  }
  
  // Level media modal functions
  function openLevelMediaModal(card){
    const imgPath = card.getAttribute('data-img');
    const videoPath = card.getAttribute('data-video');
    const levelName = card.querySelector('.level-content-title').textContent;
    
    // Create or get modal
    let modal = document.querySelector('.level-media-modal');
    if(!modal){
      modal = document.createElement('div');
      modal.className = 'level-media-modal';
      modal.innerHTML = `
        <div class="level-media-content">
          <button class="level-media-close">✕</button>
          <div class="level-media-container"></div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close button handler
      const closeBtn = modal.querySelector('.level-media-close');
      closeBtn.addEventListener('click', () => closeLevelMediaModal());
      modal.addEventListener('click', (e) => {
        if(e.target === modal) closeLevelMediaModal();
      });
      
      // ESC key handler
      document.addEventListener('keydown', (e) => {
        if(e.key === 'Escape' && modal.classList.contains('open')){
          closeLevelMediaModal();
        }
      });
    }
    
    const container = modal.querySelector('.level-media-container');
    container.innerHTML = '';
    
    // Add video if available, otherwise image
    if(videoPath){
      const video = document.createElement('video');
      video.className = 'level-media-video';
      video.src = videoPath;
      video.controls = true;
      video.autoplay = true;
      video.loop = true;
      container.appendChild(video);
    } else if(imgPath){
      const img = document.createElement('img');
      img.className = 'level-media-img';
      img.src = imgPath;
      img.alt = levelName;
      container.appendChild(img);
    } else {
      // Fallback: show level name
      container.innerHTML = `<div style="padding:60px;text-align:center;color:var(--accent-acid);font-size:2rem;font-family:var(--font-head)">${levelName}</div>`;
    }
    
    modal.classList.add('open');
  }
  
  function closeLevelMediaModal(){
    const modal = document.querySelector('.level-media-modal');
    if(modal){
      modal.classList.remove('open');
      // Stop video if playing
      const video = modal.querySelector('.level-media-video');
      if(video){
        video.pause();
        video.src = '';
      }
    }
  }
  
  function closePresent(){
    // Close overlay and immediately show TOC to prevent background flash
    overlay.classList.remove('open');
    // Open TOC immediately without delay
    openToc();
    currentMode = 'manifesto'; // Reset mode
    // Keep body in presenting mode to maintain overlay background
    document.body.classList.add('presenting');
  }

  function next(){ idx = (idx+1) % SLIDES.length; render(); }
  function prev(){ idx = (idx-1 + SLIDES.length) % SLIDES.length; render(); }

  closeBtn.addEventListener('click', closePresent);
  nextBtn.addEventListener('click', (e)=>{ e.stopPropagation(); next(); });
  prevBtn.addEventListener('click', (e)=>{ e.stopPropagation(); prev(); });

  // clicking inside the central text/wrap triggers a zoom-in animation then advances to next
  let _presentAnimating = false;
  overlay.addEventListener('click', (e)=>{
    if(!e.target.closest('.manifesto-present-wrap')) return;
    if(_presentAnimating) return;
    _presentAnimating = true;
    const wrap = overlay.querySelector('.manifesto-present-wrap');
    const txt = presentText;

    // compute zoom duration that gets faster as the presentation progresses
    const base = 420; const step = 60; // ms
    const zoomDuration = Math.max(120, base - (idx * step));

    // apply inline transition durations to make the zoom feel responsive
    wrap.style.transition = `transform ${zoomDuration}ms cubic-bezier(.2,.9,.2,1)`;
    txt.style.transition = `transform ${Math.round(zoomDuration*0.95)}ms cubic-bezier(.2,.9,.2,1), opacity ${Math.round(zoomDuration*0.7)}ms linear`;

    // start zoom-in animation
    wrap.classList.add('zooming'); txt.classList.add('zooming');

    // advance the slide after the zoomDuration elapses, then reset animation state
    setTimeout(()=>{
      next();
      txt.classList.remove('zooming');
      const wrapResetDelay = Math.max(80, zoomDuration - 120);
      setTimeout(()=>{
        wrap.classList.remove('zooming');
        wrap.style.transition = '';
        txt.style.transition = '';
        _presentAnimating = false;
      }, wrapResetDelay);
    }, zoomDuration);
  });

  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape') closePresent();
    if(e.key === 'ArrowRight') next();
    if(e.key === 'ArrowLeft') prev();
  });

  // Presentation: pinch-to-zoom (touch) and ctrl/meta+wheel (desktop) to navigate
  // Attach handlers at document level but only respond when overlay is open
  (function(){
    let pinchStart = 0;
    function dist(touches){
      const a = touches[0]; const b = touches[1];
      const dx = a.clientX - b.clientX; const dy = a.clientY - b.clientY;
      return Math.hypot(dx, dy);
    }

    window.addEventListener('touchstart', (e)=>{
      const overlay = document.querySelector('.present-overlay.open');
      if(!overlay) return;
      if(e.touches && e.touches.length === 2){
        pinchStart = dist(e.touches);
      }
    }, {passive:true});

    window.addEventListener('touchmove', (e)=>{
      const overlay = document.querySelector('.present-overlay.open');
      if(!overlay) return;
      if(e.touches && e.touches.length === 2 && pinchStart > 0){
        const d = dist(e.touches);
        const scale = d / pinchStart;
        if(scale > 1.15){ // pinch out (zoom in) -> next
          const nextBtn = overlay.querySelector('.present-btn.next');
          nextBtn && nextBtn.click();
          pinchStart = 0;
        } else if(scale < 0.85){ // pinch in (zoom out) -> prev
          const prevBtn = overlay.querySelector('.present-btn.prev');
          prevBtn && prevBtn.click();
          pinchStart = 0;
        }
      }
    }, {passive:true});

    window.addEventListener('touchend', (e)=>{ pinchStart = 0; }, {passive:true});

    // Desktop: detect ctrl/meta + wheel (typical browser zoom gesture) and use it to navigate
    window.addEventListener('wheel', (e)=>{
      const overlay = document.querySelector('.present-overlay.open');
      if(!overlay) return;
      if(e.ctrlKey || e.metaKey){
        e.preventDefault();
        if(e.deltaY < 0) { // wheel up while ctrl -> zoom in
          const nextBtn = overlay.querySelector('.present-btn.next'); nextBtn && nextBtn.click();
        } else { // wheel down -> zoom out
          const prevBtn = overlay.querySelector('.present-btn.prev'); prevBtn && prevBtn.click();
        }
      }
    }, {passive:false});
  })();

  // Smooth scroll for in-page anchors
  document.documentElement.style.scrollBehavior = 'smooth';

  // Click-to-advance for page sections: clicking a section jumps to the next section
  (function(){
    const overlayOpen = ()=> !!document.querySelector('.present-overlay.open');
    const hero = document.querySelector('.hero');
    const manifestoSec = document.getElementById('manifesto');
    const artistSec = document.getElementById('artist');
    const levelsSec = document.getElementById('levels');
    const pageSections = [hero, manifestoSec, artistSec, levelsSec].filter(Boolean);

    pageSections.forEach((sec, i)=>{
      sec.addEventListener('click', (e)=>{
        // ignore clicks on interactive controls or when overlay is open
        if(overlayOpen()) return;
        if(e.target.closest('a,button,input,textarea')) return;
        // if hero was clicked, play zoom animation then open Manifesto overlay
        if(sec === hero){
          const heroZoomDur = 420;
          hero.classList.add('hero-zooming');
          setTimeout(()=>{
            hero.classList.remove('hero-zooming');
            // open TOC overlay after zoom (pass-through effect)
            if(typeof openToc === 'function') openToc();
          }, heroZoomDur);
          return;
        }
        // if clicked the manifesto highlighted sentence, let its handler run (it stops propagation)
        const next = pageSections[i+1];
        if(next){ next.scrollIntoView({behavior:'smooth', block:'start'}); }
      });
    });
  })();

  // Background video setup and parallax on scroll
  const bgVideo = document.querySelector('.bg-video');
  if(bgVideo){
    // Ensure video loads and plays
    bgVideo.addEventListener('loadeddata', ()=>{
      bgVideo.play().catch(e=> console.log('Video autoplay prevented:', e));
    });
    bgVideo.addEventListener('error', (e)=>{
      console.error('Video load error:', e);
      // Fallback to background image if video fails
      document.body.style.backgroundImage = "url('background.jpg')";
      document.body.style.backgroundSize = 'cover';
      document.body.style.backgroundPosition = 'center';
      document.body.style.backgroundAttachment = 'fixed';
    });
    // Force play attempt
    bgVideo.play().catch(e=> {
      console.log('Initial play attempt failed, will retry on user interaction');
    });
  }

  // Background parallax on scroll (subtle) - for video
  let lastScroll = window.scrollY;
  window.addEventListener('scroll', ()=>{
    const y = window.scrollY;
    // subtle background movement for video
    if(bgVideo) {
      bgVideo.style.transform = `translateY(${-y*0.03}px)`;
    }
    lastScroll = y;
  }, {passive:true});

  // level-card tilt microinteraction
  const cards = document.querySelectorAll('.level-card');
  cards.forEach(card=>{
    card.addEventListener('mousemove', (e)=>{
      const r = card.getBoundingClientRect();
      const px = (e.clientX - r.left) / r.width;
      const py = (e.clientY - r.top) / r.height;
      const rotY = (px - 0.5) * 8; // -4 to 4 deg
      const rotX = (0.5 - py) * 6;
      card.style.transform = `perspective(900px) rotateX(${rotX}deg) rotateY(${rotY}deg) translateZ(6px)`;
    });
    card.addEventListener('mouseleave', ()=>{ card.style.transform = ''; });
  });

  // Ensure scroll starts at top on page load
  window.addEventListener('load', () => {
    window.scrollTo({ top: 0, behavior: 'auto' });
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    
    // Reset all content wraps scroll position
    if(typeof purposeWrap !== 'undefined' && purposeWrap) purposeWrap.scrollTop = 0;
    if(typeof projectStrategyWrap !== 'undefined' && projectStrategyWrap) projectStrategyWrap.scrollTop = 0;
    if(typeof artistWrap !== 'undefined' && artistWrap) artistWrap.scrollTop = 0;
    if(typeof levelsWrap !== 'undefined' && levelsWrap) levelsWrap.scrollTop = 0;
  });

  // Also reset on DOMContentLoaded
  document.addEventListener('DOMContentLoaded', () => {
    window.scrollTo({ top: 0, behavior: 'auto' });
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
  });

})();
</script>
</html>
